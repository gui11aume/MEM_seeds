\documentclass{article}

\usepackage{algorithm2e}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{authblk}
\usepackage[english]{babel}
\usepackage{blkarray}
\usepackage[font=small]{caption}
\usepackage{cite}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{url}

\setlength{\thickmuskip}{2mu plus 3mu minus 1mu}
\setlength{\medmuskip}{1mu plus 2mu minus 1mu}

\SetKwComment{Comment}{$\triangleright$\ }{}

% ---- Author affiliations ---- %

\renewcommand\Affilfont{\itshape\small}

% ---- Propositions, lemmas, defintions... ---- %

%\newtheorem{algorithm}{Algorithm}
\newtheorem{corollary}{Corollary}
\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
%\newtheorem{remark}{Remark}


% ---- Special environments (examples and remarks) ---- %

\newcounter{examplecounter}
\newenvironment{example}
{\small\vspace{0.5\baselineskip}
  \refstepcounter{examplecounter}%
  \noindent\textbf{Example \arabic{examplecounter}.}%
}{\vspace{-0.2\baselineskip}\begin{center}%
  $\star$\end{center}\vspace{0.5\baselineskip}}

\newcounter{remarkcounter}
\newenvironment{remark}
{\small\it\vspace{0.5\baselineskip}
  \refstepcounter{remarkcounter}%
  \noindent\textbf{Remark \arabic{remarkcounter}.}%
}{\vspace{0.5\baselineskip}}

\newenvironment{inset}
{\vspace{0.5\baselineskip}\begin{center}}
{\end{center}\vspace{0.5\baselineskip}}


% ---- Macros ---- %

\newcommand{\dn}[1]{\scriptstyle{\downarrow_{/#1}}}
\newcommand{\Dn}[1]{\scriptstyle{\Downarrow_{#1}}}
\newcommand{\up}[1]{\scriptstyle{\uparrow_{/#1}}}
\newcommand{\nd}{\scriptstyle{|}}
\newcommand{\modulo}[1]{\ (\mathrm{mod}\ #1)}

%---------------------------------------------------------------

\title{Calibrating seed-based heuristics to map short reads with Sesame}

\author[1,2,3]{Guillaume J. Filion}
\author[1]{Ruggero Cortini}
\author[1]{Eduard Zorita}
\affil[1]{Center for Genomic Regulation (CRG), The Barcelona Institute of
Science and Technology, Dr. Aiguader 88, Barcelona 08003, Spain.}
\affil[2]{University Pompeu Fabra (UPF), Barcelona, Spain.}
\affil[3]{Present address: Dept. Biological Sciences, University of
Toronto Scarborough}

\date{\today}

%---------------------------------------------------------------
%---------------------------------------------------------------


\begin{document}

\maketitle

\begin{abstract}
% Statement of the problem.
The increasing throughput of DNA sequencing technologies creates a need
for faster algorithms. The fate of most reads is to be mapped to a
reference sequence, typically a genome. Modern mappers rely on heuristics
to gain speed at a reasonable cost for accuracy. In the seeding heuristic,
short matches between the reads and the genome are used to narrow the
search to a set of candidate locations. Several seeding variants used in
modern mappers show good empirical performance but they are difficult to
calibrate or to optimize for lack of theoretical results.
% Summary of the results.
Here we develop a theory to estimate the probability that the correct
location of a read is filtered out during seeding, resulting in mapping
errors. We describe the properties of simple exact seeds, skip seeds and
MEM seeds (Maximal Exact Match seeds).
% Innovation.
The main innovation of this work is to use concepts from analytic
combinatorics to represent reads as abstract sequences, and to specify
their generative function to estimate the probabilities of interest.
% Durability.
We provide several algorithms, which together give a workable solution for
the problem of calibrating seeding heuristics for short reads. We also
provide a C implementation of these algorithms in a library called Sesame.
% Scope.
These results can improve current mapping algorithms and lay the
foundation of a general strategy to tackle sequence alignment problems.
% Availability
The Sesame library is open source and available for download at
\url{https://github.com/gui11aume/sesame}.
\end{abstract}


%---------------------------------------------------------------
%---------------------------------------------------------------

\section{Introduction}

\subsection{Mapping reads to genomes}

Say we use an imperfect instrument to sequence a small fragment of DNA. If
we know its genome of origin, how can we find the location of the fragment
in this genome?

The advent of high-throughput sequencing has put this question at the
center of countless applications in genetics, such as discovering
disease-causing mutations, selecting breeds of interest in agriculture or
tracing human migrations.

We will refer to this as the \emph{true location problem}. The answer to
the problem depends on the length of the read, on the error rate of the
sequencer and on one key feature of the genome: its repeat structure.
Most genomes contain repetitive sequences, \textit{i.e.}, relatively large
subsequences that are present at multiple locations. If the sequenced DNA
fragment comes from a repetitive sequence, it may be impossible to map the
read with certainty.

In general, repetitive sequences are not identical but merely
homologous---meaning that their similarity is very unlikely to occur by
chance. So if the sequenced DNA fragment originates from a repetitive
sequence, we can map the read only if we can rule out all the candidates
except one. This, in turn, depends on the similarity between the
duplicates and on the error rate of the sequencer.

Since repetitive sequences play a central role in the problem, we give the
terms ``targets'' and ``duplicates'' a meaning that will facilitate the
exposition of the theory.

\begin{definition}
\label{def_dup}
The target is the DNA fragment that was actually sequenced. Duplicates are
sequences of the genome that share homology with the target (in genetics
they are often referred to as paralogs). In this article we will focus on
short reads from complex eukaryotic genomes, so for concreteness the
reader can assume that fragments are 30-300 bp long and that duplicates
have above 75\% identity with the target.
\end{definition}

The difficulty of the true location problem is due to sequencing errors.
Occasionally, the sequence of a DNA fragment can be closer to one of the
duplicates than to the target. So the \emph{true} location of a DNA
fragment is not always the \emph{best} (as measured by the identity
between the sequence and the candidate location). This naturally leads to
asking how we can identify the \emph{best} location of the fragment in
the genome.

We will refer to this as the \emph{best location problem}. It amounts to
finding the optimal alignment between two sequences, and for this reason
has received substantial attention in bioinformatics. For the purpose of
developing a theory rooted in statistics, our main concern is to address
the true location problem, but for simplicity, we will assume that the
true location is also the best. When applicable, we will clarify the
implications of this hypothesis in the relevant sections, and we will show
in section~\ref{sec:truevsbest} that this simplifying assumption is harmless for
the present theory.


\subsection{Seeding heuristics}
\label{sec:seedheur}

Exact alignment algorithms were designed to solve the best location
problem~\cite{pmid5420325, pmid7265238}, but they are too slow to process
the large amount of data generated by modern sequencers. Instead, one uses
heuristic methods, \textit{i.e.}, algorithms that run faster but may
return an incorrect result~\cite{Waterman1984}.

The most popular heuristic for mapping DNA sequences is a filtration
method called ``seed-and-extend''. The principle is to first identify
seeds, defined as short regions of high similarity between the read and
the genome, and then use an exact alignment algorithm at the seeded
locations to evaluate the candidates and identify the optimum. Exact
alignment algorithms, such as the Needleman-Wunsch~\cite{pmid5420325} or
the Smith-Waterman~\cite{pmid7265238} algorithms return the distance or
the similarity between two sequences according to some quantitative
criterion. They are exact in the sense that they always return the correct
answer, unlike heuristic algorithms. The seed-and-extend strategy was
first proposed in FASTA~\cite{pmid2983426} and BLAST~\cite{pmid2231712} to
search for homology in sequence databases of proteins and DNA.

There are efficient methods to extract seeds, so it is possible to quickly
hone in on a small set of candidates and to reduce the search space of the
alignment algorithm. The disadvantage is that the target may not be in the
candidate set, in which case the read cannot be mapped correctly.

As a consequence, seeding methods induce a trade-off between speed and
accuracy: If the filtration is set to produce a large candidate set, the
target is likely to be discovered, with the downside that checking all the
candidates with an exact alignment algorithm will take long. Conversely,
if the filtration is set to produce a small candidate set, the process
will run faster but the target is more likely to be missed.

Importantly, the trade-off depends on the seeding method. This means that
mapping algorithms can run faster at no cost for accuracy if we can find
better seeding strategies. Progress on this line of research has largely
benefited from the improvement of computer hardware and from the
development of optimized data structures. There already exists a large
body of literature on the design of seeding algorithms; the interested
reader can find examples of those in references~\cite{sun2005designing,
pmid11934743, xu2006optimizing, kucherov2005multiseed, brejova2003vector,
pmid18684737, pmid15359419}. References~\cite{pmid16533404}
and~\cite{pmid20460430} present high-level comparisons of different
designs, and reference~\cite{navarro2001guided} gives a global overview of
filtration methods in pattern matching.

\subsection{The two types of seeding failure}
\label{sec:twotypes}

Filtering heuristics are considered to fail whenever the target is not in
the candidate set, but here we must be more specific and distinguish two
kinds of failure: In the first kind, the candidate set contains a
duplicate of the target but does not contain the target itself; in the
second kind, the candidate set contains neither the target nor any
duplicate.

The distinction is important because the duplicates of the target are
similar to the read (due to their similarity to the target), so a failure
of the first kind often looks like a success. In contrast, a failure of
the second kind is easier to flag because in this case the candidates are
not similar to the read. We will simply assume that seeding failures of
the second kind are always detected (as explained in
section~\ref{sec:random_seeds}), so that we can focus on the more
difficult case of seeding failures of the first kind.

Before going further, we introduce three terms that will simplify the
exposition.

\begin{definition}
The output of the seeding step is the candidate set. The candidate set is
the list of genomic locations where the read can be potentially mapped.
The read is always mapped to one element of the candidate set. The seeding
step is said to be
\begin{enumerate}[i)]
\item ``on target'' if the candidate set contains the target,
\item ``off-target'' if the candidate set contains a duplicate but not the target, 
\item ``null'' if the candidate set contains neither.
\end{enumerate}
In this article, we will always consider that a genomic location is in the
candidate set if and only if the read contains at least one seed with a
perfect match for this genomic location.
\end{definition}

With our assumptions, a read is mapped to the wrong location if and only
if the candidate set is off-target. Indeed, if the candidate set is null,
the read is not mapped, and if the candidate set is on target, the correct
location is discovered at the alignment step. The equivalence is granted
by the assumption that the true location is also the best, reducing the
mapping problem to a seeding problem. That being said, the true location
is not always the best in practical applications. We will show in
section~\ref{sec:truevsbest} that off-target seeding is responsible for
most of the mapping errors even without the assumption above, but for now
we maintain the strict equivalence between mapping errors and off-target
seeding.

Focusing on popular heuristics to map short reads, our aim is to develop a
method to estimate the probability that the candidate set is off-target.
Previous work pioneered a method to compute seeding probabilities but it
did not distinguish off-target from null
seeding~\cite{filion2017analytic,filion2018analytic}, and therefore did
not provide a way to estimate the frequency of mapping errors. Other
authors investigated the reliability of mapping
algorithms~\cite{pmid23872968}, but they focused on the probabilities of
random hits, recognizing that addressing the problem of incorrect mapping
requires taking into consideration the repeat structure of the genome.

The rest of the article is organized as follows: section~\ref{sec_seeds}
presents common seeding strategies used in bioinformatics,
section~\ref{sec:symbolic} presents the basic concepts of analytic
combinatorics that will be required to compute seeding probabilities,
sections~\ref{sec:offexact} to \ref{sec_offMEM} treat the cases of exact
seeds, skip seeds and MEM seeds, three common seeding heuristic used for
mapping, section~\ref{sec:sesame} presents Sesame, a C library
implementing the main results of the theory, section~\ref{sec_practical}
returns to the mapping problem and revisits the assumptions of the model,
and finally section~\ref{sec_disc} provides some perspectives on the
present work. Appendix~\ref{app_def} gathers for reference all the
definitions encountered in the text, and appendix~\ref{app_extra} contains
proofs and complements omitted from the main text.


\section{Seeds}
\label{sec_seeds}

The term ``seed'' has different meanings in computational biology. It can
designate a part of the read, a part of the genome, a particular sequence
motif, or a structured pattern of matches. Also, a seed does not always
refer to an exact match. For instance, the algorithm
PatternHunter~\cite{pmid11934743} uses spaced seeds that tolerate
mismatches. To avoid any confusion, we will adopt the convention below.

\begin{definition}
A seed is a subsequence of the read that has size at least $\gamma$
(defined by the context of the problem) and that has at least one perfect
match in the reference genome. Every genomic match of every seed is in the
candidate set. 
\end{definition}

When a seed matches a given location of the genome, we say that it is a
seed for that location. This is particularly useful in expressions such as
``seed for the target'' or ``seed for a duplicate''.

This definition presents a computational challenge: to know if a given
subsequence of a read is a seed we need to know if it exists somewhere in
the genome. This is a non trivial problem in itself, but fortunately we
can use practical methods to solve it, even when the reference genome is
very large.

These algorithms are crucial for the present theory, but describing them
in depth is outside the scope of this document. Let us just mention that
all the methods belong to a family known as exact offline string matching
algorithms, where ``offline'' means that sequences are looked up in an
index instead of the genome itself. Online methods can be used when the
reference genome is not indexed~\cite{faro2013exact}, but this case is of
little relevance in the present context.

The index is usually a hash table or a variant of the so-called
FM-index~\cite{ferragina2000opportunistic, ferragina2005indexing}. Hash
tables are typically used to index $k$-mers, which makes them useful to
search for seeds of fixed size $k$ (see~\cite{pmid30346548} for a recent
benchmark of $k$-mer hashing algorithms). In contrast, some text-indexing
structures have no set size so they can be used to search for seeds of
different lengths. This is the case of the FM-index, a compact data
structure based on the suffix array~\cite{manber1993suffix} and on the
Burrows-Wheeler transform~\cite{burrows1994block}, emulating a suffix trie
with a much smaller memory footprint~\cite{ferragina2000opportunistic,
ferragina2005indexing}.

Other methods can be efficient (\textit{e.g.}, running a bisection on the
suffix array~\cite{dobin2013star}) but the FM-index is currently the most
popular choice for seeding methods. For MEM seeds defined below, it is
even the only practical option~\cite{pmid24336412, pmid25399029,
pmid23349213, pmid19389736}. Overall, the detail is of little interest for
the theory. We simply assume that seeds are known at all times without
ambiguity because this problem has several practical solutions.

It is important to mention the case of spaced seeds. Originally introduced
in~\cite{califano1993flash} and popularized by
PatternHunter~\cite{pmid11934743}, spaced seeds feature ``don't-care''
positions allowing them to detect imperfect matches. Spaced seeds are
represented by models such as `11011', here indicating that the seeds have
length 5 and that the middle position is disregarded. At index time, the
genome is scanned with the model so that nucleotides labelled `1' are
concatenated and indexed. At search time, the query is scanned with the
model and the concatenated nucleotides labelled `1' are looked up in the
index.

Spaced seeds of weight $w$ (the number of 1s in the model) have the same
memory requirements as contiguous seeds of length $w$ but they are more
sensitive~\cite{li2006superiority}, making them very attractive for
homology search. They were used in the first generation of short-read
mappers~\cite{pmid18684737, pmid19461883, pmid19675096, pmid2945724}, but
nowadays they find more applications in genome
comparisons~\cite{pmid21209072, healy2016flak},
metagenomics~\cite{pmid26209798, pmid27540266}, genome
assembly~\cite{pmid26539459} and long-read mapping~\cite{pmid27079541}.

The success of the mainstream mappers BWA-MEM~\cite{li2013aligning} and
Bowtie2~\cite{pmid22388286} is due in part to the FM-index, which only
supports contiguous seeds. Some workarounds are
available~\cite{horton2008dislex, gagie2017compressed} but they increase
the memory footprint, explaining that short reads are typically mapped
using contiguous seeds. More generally, computing the sensitivity of
spaced seeds is challenging~\cite{pmid16819802, li2006superiority,
martin2017faster}. It is theoretically possible to do this using the
tools introduced below, but the complexity becomes prohibitive for seed
models with several don't-care positions. For these reasons we will not
treat the case of spaced seeds and we will give more detail in
section~\ref{sec_disc} about the kind of difficulties they represent for
our approach.

\subsection{Exact seeds}

Exact seeds are seeds of fixed size $\gamma$. In other words, when using
exact seeds, the candidate set consists of all the genomic locations for
which there is a perfect match of size $\gamma$ in the read. This seeding
heuristic was used in the first version of BLASTN~\cite{pmid2231712}, but
it has become unpopular for producing many short spurious hits.

Figure~\ref{fig:exact_seed_example} shows the exact seeds from an example
read with three miscalled nucleotides. The sequenced DNA fragment has
three duplicates so the seeds can match four possible locations.

\begin{figure}[h]
\centering
\includegraphics[scale=1]{exact_seed_example.pdf}
\caption{\textbf{Exact seeding.}
A sequenced DNA fragment (Read) is shown above the actual molecule
(Target), and above three paralogs of the target (Duplicates). Sequencing
errors are indicated by stars (all three are \texttt{A} misread as
\texttt{T}). The mismatches between the genomic sequences and the read are
indicated in bold. The exact seeds of size $\gamma = 7$ are indicated as
horizontal grey lines above the read. Matching regions in the genomic
sequences are shadowed in grey. Several overlapping seeds accumulate at
the center of the read, which is typical of exact seeds.}
\label{fig:exact_seed_example}
\end{figure}

Observe that erroneous nucleotides can belong to exact seeds because they
sometimes match a duplicate. For instance, the first sequencing error
matches all the duplicates and belongs to an off-target seed for the first
duplicate. However, sequencing errors that are mismatches for \emph{all}
the sequences cannot belong to a seed. This is the case of the second
sequencing error in the example, creating a local deficit of seeds.

Note the clutter in the middle of the read, where consecutive seeds match
consecutive sequences at the same location. This is typical for exact
seeds and is considered a nuisance for the implementation. Indeed, it is a
waste of computer resources to discover matches in sequences that are
already in the candidate set. In addition, this seeding method is not
particularly sensitive compared to spaced seeds~\cite{pmid11934743} so it
is used only in a few specific applications. Nevertheless, it will be
useful for the development of the present theory.


\subsection{Skip seeds}

Skip seeds have a fixed size $\gamma$, but unlike exact seeds they cannot
start at every nucleotide. Instead, a certain amount of nucleotides is
skipped between every seed. This is a way to reduce the overlapping
matches at the same location, at the cost of sensitivity. This seeding
heuristic is the core of Bowtie2~\cite{pmid22388286}, where seeds have
size $\gamma=16$ and are separated by 10 nucleotides (9 positions are
skipped). We will refer to seeds where $n$ nucleotides are skipped as
``skip-$n$ seeds''. For instance, Bowtie2 uses skip-9 seeds.

\begin{figure}[h]
\centering
\includegraphics[scale=1]{skip_seed_example.pdf}
\caption{\textbf{Example of skip seeds.}
The sequences and the annotations are the same as in
Figure~\ref{fig:exact_seed_example}, but here we use skip-1 seeds. In other
words, seeds can never start at nucleotides 2, 4, 6 \textit{etc}. To
highlight the difference with Figure~\ref{fig:exact_seed_example}, the
missing seeds are represented by dotted lines.}
\label{fig:skip_seed_example}
\end{figure}

Figure~\ref{fig:skip_seed_example} shows what happens when exact seeds are
replaced by skip-1 seeds on the read of Figure~\ref{fig:exact_seed_example}.
Here the size is still $\gamma=7$ but 1 nucleotide is skipped between
seeds. This amounts to removing every second seed. The consequence is that
there are fewer overlapping matches at the center of the read, but the
only seed for the second duplicate is lost. This is a rather positive
outcome because there is one off-target location fewer in the candidate
set, but the same might happen to the target.

It is clear that skipping nucleotides reduces the sensitivity of the
seeding step, but to what extent? One could test this empirically, but the
answer depends on the seed length, the number of nucleotides that are
skipped, the error rate of the sequencer and the size of the reads. The
present theory will allow us to make general statements about the
performance of skip seeds against exact seeds in different contexts.


\subsection{MEM seeds}

MEM seeds (where MEM stands for Maximal Exact Match) are somewhat harder
to define. Unlike exact seeds and skip seeds, their size is variable. They
are used in BWA-MEM~\cite{li2013aligning} where they give good empirical
results. To describe MEM seeds, let us first clarify the meaning of
``Maximal Exact Match''.

\begin{definition}
A Maximal Exact Match (MEM) is a subsequence of the read that is present
in the reference genome and that cannot be extended---either because the
read ends or because the extended subsequence is not in the genome.
\end{definition}

A \emph{MEM seed} is simply a MEM of size size $\gamma$ or greater.
Figure~\ref{fig:MEM_example} shows what happens when using MEM seeds on the
read of Figure~\ref{fig:exact_seed_example}. Observe that the clutter at the
center of the read has disappeared because consecutive matches are fused
into a few MEM seeds.

\begin{figure}[h]
\centering
\includegraphics[scale=1]{MEM_example.pdf}
\caption{\textbf{Example of MEM seeds.}
The sequences and the annotations are the same as in
Figure~\ref{fig:exact_seed_example}, but here we use MEM seeds of minimum
size $\gamma=7$. The clutter at the center of the read has disappeared and
there is at least one seed for each sequence.}
\label{fig:MEM_example}
\end{figure}

Two consecutive MEM seeds can overlap, in which case they always match
distinct sequences of the genome (otherwise neither of them would be a MEM
seed). There does not have to be any overlap though, because a nucleotide
can be a mismatch against \emph{all} the sequences, like the second read
error for instance.

Note that a MEM does not always match a single sequence of the genome. For
instance, the rightmost MEM seed matches two distinct genomic sequences.
This case motivates the following definition, which will play an important
role later.

\begin{definition}
A \emph{strict} MEM seed has a single match in the genome.
A \emph{shared} MEM seed has several matches in the genome.
\end{definition}

Compared to seeds of fixed size, MEM seeds have two counter-intuitive
properties. The first is that there are cases where there cannot be any
on-target seed, even when changing the minimum seed size $\gamma$.
Figure~\ref{fig:full_masking_example} shows such an example. Even though
there is a single sequencing error, the read has no MEM seed for the
target. Lowering $\gamma$ does not change this, so there is no way to
discover the true location using MEM seeds (even though it is the best
location).

\begin{figure}[h]
\centering
\includegraphics[scale=1]{full_masking_example.pdf}
\caption{\textbf{Issues with MEM seeds: inaccessible targets.}
The read, the MEM seeds and the sequences are represented as in
Figure~\ref{fig:MEM_example}. The MEM seeds matching the two duplicates
at the bottom effectively hide the target, so it cannot be discovered.
This can occur even when the true location is the best candidate and when
there is a single error on the read.}
\label{fig:full_masking_example}
\end{figure}

The second counter-intuitive property is that shortening a read can
sometimes generate a MEM seed for the target. Figure~\ref{fig:short_vs_long}
shows an example of this case. There is no MEM seed for the target, but
there would be if the read were two nucleotides shorter on the right
side. Indeed, in this case there would be a shared MEM seed matching
the target and the first duplicate (provided $\gamma \leq 12$).


\begin{figure}[h]
\centering
\includegraphics[scale=1]{short_vs_long_example.pdf}
\caption{\textbf{Issues with MEM seeds: too long reads.}
The read, the MEM seeds and the sequences are represented as in
Figure~\ref{fig:MEM_example}. There would be a good seed (shared) if the
read were two nucleotides shorter. The true location is hidden by
the last two nucleotides.}
\label{fig:short_vs_long}
\end{figure}

These examples show that MEM seeds can perform worse than seeds of fixed
size. MEM seeds yield fewer candidates and therefore speed up the mapping
process, but the question is at what cost? The theory developed here will
allow us to compute the probability that a read has no MEM seed for the
target and thus that the true location is missed at the seeding stage.


\section{Model and strategy}
\label{sec:symbolic}

\subsection{Sequencing errors and divergence of the duplicates}
\label{sec:error}

We now need to model the sequencing and duplication processes so that
we can compute the probabilities of the events of interest. We assume that
the sequencing instrument has a constant substitution rate $p$, and that
insertions and deletions never occur. When a substitution occurs, we
assume that the instrument is equally likely to output any one of the
remaining three nucleotides. This corresponds more or less to the error
spectrum of the Illumina sequencing technology~\cite{pmid21576222}.

Next, we assume that the target sequence has $N \geq 0$ duplicates, so
that there are $N$ off-target sequences. We further assume that
duplication happened instantaneously at some point in the past and that
all $N+1$ sequences diverge independently of each other at a constant
rate. In other words, we ignore the complications due to the genealogy of
the duplication events. Instead, we simply assume that at each nucleotide
position, any given duplicate is identical to the target with probability
$1-\mu$. If it is not, we assume that the duplicate sequence can be any of
one the three remaining nucleotides (\textit{i.e.} each is found with
probability $\mu/3$).

Note that read errors are always mismatches against the target (because we
assume that the target is the true sequence), and they match each
duplicate with probability $\mu/3$. Correct nucleotides are always matches
for the target, and they match each duplicate with probability $1-\mu$.

Before going further, we also need to move a practical consideration out
of the way. Seeds can match any sequence of the genome, not just the
target or the duplicates. However, we will ignore matches in the rest of
the genome because such random matches are unlikely to cause a mapping
error when seeding is off-target, contrary to matches in duplicates.
Neglecting those will greatly simplify the exposition of the theory
without loss of generality. We will explain in
section~\ref{sec:random_seeds} how to deal with this practical case and
how to identify those matches as off-target. Until then, we will consider
that the target and the duplicates are the only sequences in the reference
genome.


\subsection{Weighted generating functions}

The central object of analytic combinatorics is the generating function,
and for our purpose we will use a special kind known as \emph{weighted
generating function}.

\begin{definition}
\label{def:GF}
Let $\mathcal{A}$ be a set of combinatorial objects such that $a \in
\mathcal{A}$ has a size $|a| \in \mathbb{N}$ and a weight $w(a) \in
\mathbb{R}^+$. The weighted generating function of $\mathcal{A}$ is
defined as

\begin{equation}
\label{eq:GF1}
A(z) = \sum_{a \in \mathcal{A}} w(a) z^{|a|},
\end{equation}
Expression (\ref{eq:GF1}) also defines a sequence $(a_k)_{k \geq 0}$ such
that 

\begin{equation*}
A(z) = \sum_{k=0}^\infty a_k z^k.
\end{equation*}

By definition $a_k = \sum_{a \in A_k}w(a)$, where $A_k$ is the class of
objects of size $k$ in $\mathcal{A}$. The number $a_k$ is the
total weight of objects of size $k$.
\end{definition}

To give an example, assume that a particular symbol, say $\Downarrow$, has
a probability of occurrence equal to $p$. The weighted generating function
words containing only this symbol is $pz$. The weight of the word is its
probability (here equal to $p$) and the size is its length (here 1).

In this document we will focus on the weighted generating function $A(z)$
of the set $\mathcal{A}$ of reads that do not have on-target seeds
(\textit{i.e.} reads for which seeding is either null or off-target). The
weight of a read is its probability of occurrence and the size $k$ is its
number of nucleotides. The coefficient $a_k$ is thus the proportion of
reads of size $k$ that do not have an on-target seed, which is the
quantity of interest.

The motivation for introducing weighted generating functions is that
operations on combinatorial objects translate into operations on their
weighted generating functions. If $A(z)$ and $B(z)$ are the weighted
generating functions of two mutually exclusive sets $\mathcal{A}$ and
$\mathcal{B}$, the weighted generating function of $\mathcal{A} \cup
\mathcal{B}$ is $A(z) + B(z)$, as evident from expression (\ref{eq:GF1}).
Size and weight can be defined for pairs of objects in $\mathcal{A} \times
\mathcal{B}$ as $|(a,b)| = |a| + |b|$ and $w(a,b) = w(a)w(b)$. In other
words the sizes are added and the weights are multiplied.  With this
convention, the weighted generating function of the Cartesian product
$\mathcal{A} \times \mathcal{B}$ is $A(z)B(z)$. This simply follows from
expression (\ref{eq:GF1}) and from

\begin{equation*}
A(z)B(z) =
\sum_{a\in \mathcal{A}}w(a)z^{|a|} \sum_{b\in \mathcal{B}}w(b)z^{|b|}
= \sum_{(a,b) \in \mathcal{A} \times \mathcal{B}} w(a)w(b)z^{|a|+|b|}.
\end{equation*}

These two operations are all we need in order to compute the weighted
generating functions of the reads of interest. Addition corresponds to
creating a new family by merging reads from families $\mathcal{A}$ and
$\mathcal{B}$. Multiplication corresponds to creating a new family by
concatenating reads from families $\mathcal{A}$ and $\mathcal{B}$.

\subsection{Analytic representation}

The analytic combinatorics framework relies on a strategy referred to as
the \emph{symbolic method}~\cite{sedgewick2013introduction}. The idea is
to combine simple objects into more complex objects. Each combinatorial
operation on the objects corresponds to a mathematical operation on their
weighted generating functions. One can thus obtain the weighted generating
function of complex objects, whose coefficients $a_k$ ($k \geq 0$) are the
probabilities of interest~\cite{regnier2000unified, nicodeme2002motif,
sedgewick2013introduction}.

As explained in~\cite{filion2017analytic} and~\cite{filion2018analytic},
we recode the reads in alphabets of custom symbols and we specify a
construction plan of the reads using a so-called \emph{transfer matrix}
$M(z)$. The transfer matrix specifies which types of segments can follow
each other in the reads of interest: the entry at coordinates $(i,j)$ is
the weighted generating function of segments of type $j$ that can be
appended to segments of type $i$.

$M(z)$ contains the weighted generating functions of all the reads that
consist of a single fragment. From the basic operations on weighted
generating functions, $M(z)^s$ contains the weighted generating functions
of all the reads that consist of $s$ segments. Therefore, the entry at
coordinates $(i,j)$ of the matrix $M(z) + M(z)^2 + M(z)^3 + \ldots = M(z)
\cdot (I-M(z))^{-1}$ is the weighted generating function of the reads of
any size and any number of segments, that end with a segment of type $j$
and that can be appended to a segment of type $i$. The examples below will
clarify the key steps of this strategy.

A complete description of how to compute seeding probabilities with the
symbolic method can be found in~\cite{filion2017analytic,
filion2018analytic}. The interested readers can also find more about
analytic combinatorics in the popular
textbooks~\cite{flajolet2009analytic, sedgewick2013introduction}.


\subsection{Example 1: on-target exact seeds}
\label{sec:example_exact}

We highlight the strategy above with an example that will turn out to be
central for the development of the theory. In addition, it is simple
enough to provide a gentle introduction to the general methodology. This
example was described in detail in~\cite{filion2017analytic} and
in~\cite{filion2018analytic}, but we repeat it here with a different
formalism to fit the present manuscript.

The first step is to note that the nucleotide sequence of the read is
irrelevant. Indeed, the read has an on-target seed if and only if it
contains a stretch of $\gamma$ nucleotides without error. For this reason,
we recode reads as sequences of correct or erroneous nucleotides.

We define the mismatch alphabet $\mathcal{A}_0 = \{\square, |,
\Downarrow\}$, where $\square$ represents a correct nucleotide,
$\Downarrow$ represents an erroneous nucleotide and $|$ is a special
symbol appended after the last nucleotide to mark the end of the read. It
is not associated with a nucleotide and therefore has size 0.

This recoding allows us to partition the read in an important way.

\begin{definition}
\label{def:seg}
A terminator is any symbol that is different from the symbol $\square$. A
segment is a sequence of 0 or more $\square$ symbols followed by a
terminator. The tail is the last segment of the read, where the terminator
is always the special symbol $|$.
\end{definition}

Since the decomposition of the read in segments is unique, we can view a
read as a sequence of segments with a tail, instead of a sequence of
nucleotides. Figure~\ref{fig:simple} shows an example of decomposition in
segments. On-target seeds cannot contain sequencing errors, therefore they
must be completely embedded in a segment. So the sizes of the segments
indicate whether the read contains an on-target seed or not.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{sketch_simple.pdf}
\caption{\textbf{The mismatch encoding.}
An example read is represented in the mismatch alphabet. The symbol
$\Downarrow$ represents a mismatch against the target (an erroneous
nucleotide) and the symbol $\square$ represents a match (a correct
nucleotide). The symbol $|$ is appended to the end of the read. The
symbolic sequence of the target is represented below, where an open square
stands for a match and a closed square stands for a mismatch.}
\label{fig:simple}
\end{figure}

The probability of occurrence of the symbol $\Downarrow$ is $p$ (the error
rate of the sequencer) so the probability of occurrence of the $\square$
symbol is $1-p = q$. Both symbols have size 1, so their respective
weighted generating functions are $pz$ and $qz$. Using the rule for
concatenation, we see that a segment of $i$ symbols $\square$ followed by
a terminator has weighted generating function $(qz)^ipz$. The final symbol
$|$ has size 0, so a tail segment of $i$ symbols $\square$ followed by the
symbol $|$ has weighted generating function $(qz)^i$.

The key insight is that the reads without on-target seed are exactly the
reads that are made of segments with fewer than $\gamma$ symbols
$\square$, where $\gamma$ is the minimum seed size. The weighted
generating function of such segments is $\big( 1+qz+\ldots+(qz)^{\gamma-1}
\big) pz$, and that of the tail is $1+qz+\ldots+(qz)^{\gamma-1}$. This
gives a construction plan that can be encoded in a transfer matrix.

Reads consist of only two kinds of objects: the segments terminated by
$\Downarrow$ (or $\Downarrow$-segments for short) and the tails, so the
dimension of the transfer matrix is $2 \times 2$. A $\Downarrow$-segment
can be followed by another $\Downarrow$-segment or by the tail. The tail
cannot be followed by anything. The expression of the transfer matrix
$M_0(z)$ is thus
\begin{equation*}
\begin{blockarray}{ccc}
   & \scriptstyle{\Downarrow} & \scriptstyle{|} \\
\begin{block}{c[cc]}
\scriptstyle{\Downarrow} & \big( 1+qz+\ldots+(qz)^{\gamma-1}
\big) pz  & 1+qz+\ldots+(qz)^{\gamma-1} \\
\scriptstyle{|} & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
where $p$ is the error rate of the sequencer, $q=1-p$ and $\gamma$ is the
minimum seed length. In the representation above, the different types of
segments are identified by their terminator, indicated in the margins for
clarity.

We can compute the matrix $M_0(z) + M_0(z)^2 + \ldots = M_0(z) \cdot
(I-M_0(z))^{-1}$ and extract the entry of interest, which is the top right
term---associated with terminators $\Downarrow$ and $|$. To see why,
observe that every read can be prepended by $\Downarrow$-segments and only
by those (not by a tail). Thus, reads are precisely the sequences of
segments that can follow the symbol $\Downarrow$ and that are terminated
by a tail, whose weighted generating function is the top right entry of
the matrix. In appendix~\ref{app_ex1}, we show that this term is equal to
\begin{equation}
\label{eq:F}
\frac{1+qz+\ldots+(qz)^{\gamma-1}}
  {1-\big(1+qz+\ldots+(qz)^{\gamma-1} \big) pz}.
\end{equation}

This function can be expanded as a Taylor series $a_0 + a_1z + a_2z^2 +
\ldots$, but the coefficients $a_0, a_1, a_2, \ldots$ are unknown. By
construction, $a_k$ is the quantity of interest, \textit{i.e.} it is the
probability that a read of size $k$ does not contain an on-target seed of
minimum size $\gamma$, so we now need to extract the Taylor coefficients
from expression (\ref{eq:F}). There are several methods to do so; the one
we choose here is to build a recurrence equation. In
appendix~\ref{app_rec}, we show that

\begin{equation}
\label{eq:recur}
a_k = 
\begin{cases}
1            &\quad\text{if } k < \gamma, \\
1 -q^\gamma &\quad\text{if } k = \gamma, \\
a_{k-1} -pq^\gamma \cdot a_{k-\gamma-1} &\quad\text{otherwise.}
\end{cases}
\end{equation}

Note that for $k < \gamma$, the read is too short so the probability that
it contains no seed is 1; for $k = \gamma$, the read contains a seed if
and only if it has no error, which occurs with probability $q^\gamma$.

The terms of interest can be computed recursively using expression
(\ref{eq:recur}). This approach is very efficient because every iteration
involves at most one multiplication and one subtraction. Also, the default
floating-point arithmetic on modern computers gives sufficient precision
to not worry about numeric instability for the problems considered here
(we rarely need to compute those probabilities for reads above 500
nucleotides).

This example shows how the symbolic approach yields a non-trivial and yet
simple algorithm to compute the probability that a read of size $k$ does
not contain an on-target exact seed.


\subsection{Example 2: on-target skip seeds}
\label{sec:example_skip}

We go through another essential example, namely we devise a method to
compute the probability that a read contains no on-target skip seed. Using
the same strategy as in the previous example, we start by recoding the
reads using a specialized alphabet to solve this problem.

We need to know whether a nucleotide is a sequencing error, but this time
we also need to know its phase in the repeated cycles of skipped
positions. For this, we define the skip-$n$ alphabet $\mathcal{A}_n =
\{\square, |, \Downarrow_0, \Downarrow_1, \ldots, \Downarrow_n \}$. Again,
the symbol $\square$ represents a correct nucleotide and the symbol $|$ is
a terminator added at the end of the read. The symbols $\Downarrow_j$ ($ 0
\leq j \leq n$) represent sequencing errors and $j$ indicates the number
of nucleotides until the next non-skipped position (\textit{i.e.} $j=0$
for nucleotides immediately before a non-skipped position and $j=n$ for
nucleotides at a non-skipped position).

As per definition~\ref{def:seg}, segments in this alphabet are sequences
of 0 or more $\square$ symbols followed by any of the symbols
$\Downarrow_j$ or by the symbol $|$. Given that this decomposition is
unique, we can again view a read as a sequence of segments with a tail.
The example of Figure~\ref{fig:simple} is shown again in
Figure~\ref{fig:skip}, where segments in the mismatch alphabet have been
replaced by segments in the skip-3 alphabet.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{sketch_skip.pdf}
\caption{\textbf{The skip encoding.}
The read of Figure~\ref{fig:simple} is represented in the skip-3 alphabet.
The symbols $\Downarrow_j (j = 1,2,3)$ represent mismatches against the
target (they are erroneous nucleotides) and the $\square$ symbol
represents a match (it is a correct nucleotide). The vertical bars
indicate non-skipped positions (the potential start of a seed). The number
$j$ in $\Downarrow_j$ indicates the number of nucleotides until the next
non-skipped position. For $j=0$ the next nucleotide is not skipped.
Other features are as in Figure~\ref{fig:simple}.}
\label{fig:skip}
\end{figure}

The probability of occurrence of a sequencing error is $p$, so every
symbol $\Downarrow_j$ has the same weighted generating function
$pz$---provided the next non-skipped position is at distance $j$,
otherwise the weighted generating function is 0. The weighted generating
function of the symbol $\square$ is again $qz$, so a segment with $i$
symbols $\square$ followed by the symbol $\Downarrow_j$ has weighted
generating function $(qz)^ipz$---if the next non-skipped position is at
distance $j$, otherwise it is 0. As in the previous example, a tail
segment with $i$ symbols $\square$ followed by the symbol $|$ has weighted
generating function $(qz)^i$.

This case is more complex than the previous one: reads without on-target
skip seed of minimum size $\gamma$ can contain segments with $\gamma$ or
more $\square$ symbols. For instance, the read shown in
Figure~\ref{fig:skip} contains a stretch of 9 nucleotides without errors
but it has no seed of minimum size $\gamma=9$. More generally, if there is
a sequencing error $i$ nucleotides before the next non-skipped position,
there can be up to $\gamma+i-1$ symbols $\square$ in a row.

Expressed in different words, it is possible to append segments with up to
$\gamma+i-1$ symbols $\square$ after segments terminated by $\Downarrow_i$
($\Downarrow_i$-segments for short). Each of those $\gamma+i$ possible
segments is associated with a different terminator, depending on how far
ahead the next non-skipped position lies. In Figure~\ref{fig:skip}, for
instance, the second segment is terminated by $\Downarrow_1$ because there
is 1 nucleotide before the next non-skipped position. If the segment were
1 nucleotide longer, the terminator would have to be $\Downarrow_0$.

The main issue is that segments of different lengths can be terminated by
the same symbol. Going back to Figure~\ref{fig:skip}, the third segment
has length 10 and is terminated by $\Downarrow_3$. It would also be
terminated by $\Downarrow_3$ if it had length 2 or length 6. In the
general case, the entries of the transfer matrix show some periodicity
modulo $n+1$.

Denote $H_{i,j}(z)$ the weighted generating function of
$\Downarrow_j$-segments that can follow a $\Downarrow_i$-segment. The
total number of segments that can follow a $\Downarrow_i$-segment is
$\gamma+i$. Among them, the shortest $\Downarrow_j$-segment has size
$\ell_0$ to be determined below, and the others have sizes $\ell_0+(n+1),
\ell_0+2(n+1), \ldots, \ell_0+m(n+1)$, for some integer $m$. This $m$ is
the largest number such that $\ell_0+m(n+1) \leq \gamma+i$, so $m =
\lfloor (\gamma+i-\ell_0)/(n+1)\rfloor$, where $\lfloor \ldots \rfloor$ is
the ``floor'' function.

Those segments follow a $\Downarrow_i$-segment, so they start $i$
nucleotides before the next non-skipped position. The shortest following
segment that ends $j$ nucleotides before a non-skipped position has length
$\ell_0 = i-j$ if $i > j$, and $n+1-j+i$ otherwise. This is equivalent to
defining $\ell_0$ as $x+1$ where $x$ is the number of $\square$ symbols of
the shortest $\Downarrow_j$-segment, \textit{i.e.} $x = i-j-1
\modulo{n+1}$.

With these notations, he shortest $\Downarrow_j$-segment consists of $x$
symbols $\square$ followed by the $\Downarrow_j$ terminator, so it has
weighted generating function $(qz)^xpz$. The other segments have a
multiple of $n+1$ extra $\square$ symbols so their weighted
generating functions are $(qz)^{x+(n+1)}pz, (qz)^{x+2(n+1)}pz, \ldots,
(qz)^{x+m(n+1)}pz$. Summing over those cases, we finally obtain
\begin{eqnarray}
\label{eq_H}
H_{i,j}(z) &=& (qz)^x \big( 1 + (qz)^{n+1} +
  \ldots + (qz)^{m(n+1)} \big)pz, \\
\notag
  &\;& \text{where } x = i-j-1 \modulo{n+1},
  \text{ and } m = \left\lfloor
  \frac{\gamma+i-1-x}{n+1} \right\rfloor.
\end{eqnarray}

Denote $J_i(z)$ the weighted generating function of tail segments that can
follow a $\Downarrow_i$-segment. There are $\gamma+i$ such tails, each
consisting of 0 to $\gamma+i-1$ symbols $\square$ followed by the special
$|$ terminator for the end of the read. The $|$ has size 0 so its weighted
generating function is 1. Once again summing over the different cases, we
obtain
\begin{equation}
\label{eq_J}
J_i(z) = 1 + qz + (qz)^2 + \ldots + (qz)^{\gamma+i-1}.
\end{equation}

Finally, the expression of $M_n(z)$ the transfer matrix of reads in the
skip-$n$ alphabet is
\begin{equation}
\label{eq_matrix_Mn}
\begin{blockarray}{cccccc}
   & \Dn{0} & \Dn{1} & \ldots & \Dn{n} & \nd \\
\begin{block}{c[ccccc]}
\Dn{0} & H_{0,0}(z) & H_{0,1}(z) & \ldots & H_{0,n}(z) & J_0(z) \\
\Dn{1} & H_{1,0}(z) & H_{1,1}(z) & \ldots & H_{1,n}(z) & J_1(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\Dn{n} & H_{n,0}(z) & H_{n,1}(z) & \ldots & H_{n,n}(z) & J_n(z) \\
\nd & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation}
where $p$ is the error rate of the sequencer, $q=1-p$, $n$ is the number of
skipped nucleotides between potential seeds, $\gamma$ is the minimum seed
length, and polynomials $H_{i,j}(z)$ and $J_i(z)$ are defined in
expressions (\ref{eq_H}) and (\ref{eq_J}).

In appendix~\ref{app_Mn}, we present a transfer matrix with a simpler
expression that will prove useful in section~\ref{sec_offskip}. The
version of appendix~\ref{app_Mn} is simpler, but the expression above has
some advantages that will be explained below.

The weighted generating function of interest is the top right entry of the
matrix $M_n(z) + M_n(z)^2 + \ldots = M_n(z)\cdot(I-M_n(z))^{-1}$. To see
why, observe that, at the start of every read, the next nucleotide is a
non-skipped position, so every read can be prepended by
$\Downarrow_0$-segments and only by those. Thus, reads are precisely the
sequences of segments that can follow the symbol $\Downarrow_0$ and that
are terminated by a tail, whose weighted generating function is the entry
of the matrix associated with terminators $\Downarrow_0$ and $|$.

By construction, the Taylor expansion of the top right term in the matrix
$M_n(z)\cdot(I-M_n(z))^{-1}$ contains the probabilities of interest. More
specifically, if the Taylor series of this term is $a_0 + a_1 z + a_2 z^2
+ \ldots$, then $a_k$ is the probability that a read of size $k$ contains
no skip-$n$ seed of minimum size $\gamma$.

But $M_n(z)$ is too complex to find a closed expression for $M_n(z) \cdot
(I-M_n(z))^{-1}$ or its top right term. Instead, we return to the
definition $M_n(z) + M_n(z)^2 + \ldots$ and show in
appendix~\ref{app_skip} that the coefficient of interest, $a_k$, only
depends on the first $k+1$ terms of the sum. So for reads of size $k$ or
lower, we only need to compute the matrix $M_n(z) + M_n(z)^2 + \ldots +
M_n(z)^{k+1}$ and work out the Taylor expansion of the top right term.

But we can do better: since we are only interested in the coefficients up
to order $k$, we can perform all algebraic operations on truncated
polynomials of order $k$, \textit{i.e.} we discard the coefficients of
order $k+1$ or greater when multiplying two polynomials.

But we can do even better: a read with $s+1$ segments contains $s$ errors,
so the top right entry of $M_n(z)^{s+1}$ is the weighted generating
function of reads with $s$ errors that have no seed of minimum size
$\gamma$. Computing the partial sum $M_n(z) + M_n(z)^2 + \ldots +
M_n(z)^s$ instead of $M_n(z) + M_n(z)^2 + \ldots + M_n(z)^{k+1}$
corresponds to neglecting reads with $s$ or more errors. For $s$
sufficiently large, such reads are exceedingly rare so we can obtain
accurate estimates without computing all the powers of $M_n(z)$ up to
order $k$.

The number of errors $X$ in a read of size $k$ has a Binomial
distribution $X \sim B(k,p)$. From~\cite{arratia1989tutorial} we can bound
the probabilities of the tail with the expression

\begin{equation}
\label{eq:bound}
Pr(X \geq s) \leq \exp \left( (s-k)\log \frac{k-s}{k(1-p)} -s\log
\frac{s}{kp} \right).
\end{equation}

Using the formula above, we can thus bound the probability that a read has
$s+1$ or more segments. We compute $M_n(z) + M_n(z)^2 + \ldots
+M_n(z)^{s+1}$ where the weighted generating functions have been replaced
by truncated polynomials and we extract the top right entry. When the
right-hand side of expression (\ref{eq:bound}) is lower than a set
fraction $\varepsilon$ of the current value of $a_k$, we stop the
computations. Typically $\varepsilon = 0.01$ so this method ensures that
the probabilities that a read of size $k$ has no on-target skip seed are
accurate to within 1\%.

If we used $M_n^*(z)$the transfer matrix of appendix~\ref{app_Mn}, the top
right entry of $M_n(z)^{s+1}$ is not the weighted generating function of
reads with $s$ errors, so (\ref{eq:bound}) is not an upper bound for the
neglected terms of the sum. As a consequence, one would have to compute
more terms in the partial sum $M_n(z) + M_n(z)^2 + \ldots + M_n(z)^{s+1}$
to reach the same accuracy. The transfer matrix shown in expression
(\ref{eq_matrix_Mn}) is not the simplest, but it has the benefit of
requiring fewer iterations.

\begin{remark}
Observe that when $n=0$ the matrix $M_n(z)$ is identical to the matrix
$M_0(z)$ of section~\ref{sec:example_exact}. This is consistent with the
fact that exact seeds are skip-$0$ seeds.
\end{remark}

\section{Off-target exact seeds}
\label{sec:offexact}

We now turn our attention to the problem of computing the probability that
the seeding process is off-target when using exact seeds---recall from
section~\ref{sec:twotypes} that off-target seeding means that the
candidate set contains a duplicate but not the target.

If there is no duplicate (\textit{i.e.} $N = 0$), seeding cannot be
off-target, it can only be on target or null. So from here we assume that
the target has $N \geq 1$ duplicates. Let $S_0$ denote the event that
there is an on-target seed and let $S_j$ denote the event that there is a
seed for the $j$-th duplicate. We are thus interested in computing
$P\big(\overline{S}_0 \cap (S_1 \cup \ldots \cup S_N)\big)$, where
$\overline{S}_j$ denotes the complement of the event $S_j$. First observe
that
\begin{equation}
\label{eq:pcomp}
P\big(\overline{S}_0 \cap (S_1 \cup \ldots \cup S_N)\big) =
P(\overline{S}_0) - P\big(\overline{S}_0 \cap \overline{S}_1 \cap \ldots
\cap \overline{S}_N\big).
\end{equation}

Since the duplicates are assumed to evolve independently of each other and
through the same mutagenesis process, the events $S_j$ ($1 \leq j \leq N$)
are independent and identically distributed conditionally on
$\overline{S}_0$. We can thus write
\begin{eqnarray}
\notag
P(\overline{S}_0 \cap \ldots \cap \overline{S}_N) &=&
  P(\overline{S}_0) \cdot P(\overline{S}_1 \cap \ldots \cap
  \overline{S}_N | \overline{S}_0) \\
\label{eq:Pnull}
  &=& P(\overline{S}_0) \cdot P(\overline{S}_1 | \overline{S}_0)^N =
  P(\overline{S}_0) \cdot \left( \frac{P(\overline{S}_0 \cap
\overline{S}_1)}{P(\overline{S}_0)} \right)^N.
\end{eqnarray}
Combining the two equations above, we obtain
\begin{equation}
\label{eq:Poff}
P\big(\overline{S}_0 \cap (S_1 \cup \ldots \cup S_N)\big) =
P(\overline{S}_0) - P(\overline{S}_0) \cdot \left( \frac{P(\overline{S}_0
\cap \overline{S}_1)}{P(\overline{S}_0)} \right)^N.
\end{equation}

Hence, the probability that seeding is off-target is a function of just
two quantities: $P(\overline{S}_0)$ and $P(\overline{S}_0 \cap
\overline{S}_1)$. The first is the probability that the read has no seed
for the target, which we have already computed in
section~\ref{sec:example_exact} using recursive expression
(\ref{eq:recur}). We now need to find a way to compute $P(\overline{S}_0
\cap \overline{S}_1)$.

\begin{remark}
Observe that expression (\ref{eq:Pnull}) is the probability of null
seeding (the read contains no seed for the target or any of its
duplicates). Since it is also a function of just $P(\overline{S}_0)$ and
$P(\overline{S}_0 \cap \overline{S}_1)$, it can be computed at no
additional cost. This probability is less relevant than the probabilities
that the seeding process is on target or off-target, but at times, it may
be useful to know the probability that a read is not mappable, especially
when reads are relatively short.
\end{remark}

\subsection{The dual encoding}
\label{sec:dual}

$P(\overline{S}_0 \cap \overline{S}_1)$ is the probability that the read
has no seed for the target or for the first duplicate---numbering is
arbitrary here, the first duplicate can be any fixed duplicate. As in
section~\ref{sec:symbolic}, we first recode the reads using a specialized
alphabet to simplify the problem.

It will be useful to consider a more general problem where we
have two sequences of interest labelled $+$ and $-$. The $+$ sequence
stands for the target and that the $-$ sequence stands for its duplicate.
We then define the dual alphabet $\tilde{\mathcal{A}}_0 = \{\square, |,
\downarrow_{/1}^-, \downarrow_{/2}^-, \ldots, \downarrow_{/1}^+,
\downarrow_{/2}^+, \ldots, \Downarrow\}$. The symbols $\downarrow_{/j}^-$
($j \geq 1$) signify that the nucleotide is a mismatch against the $-$
sequence only, the symbols $\downarrow_{/j}^+$ ($j \geq 1$) signify that
it is a mismatch against the $+$ sequence only, and the symbol
$\Downarrow$ signifies that it is a mismatch against both. As before,
every other nucleotide is replaced by the symbol $\square$, and the
terminator $|$ is appended to the end of the read. We again define reads
as sequences of segments (zero or more $\square$ symbols followed by a
terminator), except that now the terminators are the symbols
$\downarrow_{/j}^-$, $\downarrow_{/j}^+$ ($j \geq 1$) and $\Downarrow$.
The tail, as usual, is terminated by the symbol $|$.

The index $j$ in the symbol $\downarrow_{/j}^-$ indicates the match length
of the $+$ sequence (note that this is not the same as the number of
$\square$ symbols in the segment). Likewise, the index $j$ in the symbol
$\downarrow_{/j}^+$ indicates the match length of the $-$ sequence. For
instance, the symbol $\downarrow_{/7}^-$ indicates that the nucleotide is
a mismatch against the $-$ sequence, that it is a match for the $+$
sequence, and that the six preceding nucleotides were also a match for the
$+$ sequence (but the nucleotide before that was a mismatch against the
$+$ sequence). The terminators thus encode the local state of the read.

Figure~\ref{fig:dual} shows an example of read in the dual encoding. The
$+$ and $-$ sequences are shown below the read, with matches represented
as open squares and mismatches as closed squares. It is visible from this
example that symbols $\downarrow^-_{/j}$ and $\downarrow^+_{/j}$ alternate
whenever the mismatches hit different sequences. The symbol $\Downarrow$
occurs only when a nucleotide is a double mismatch.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{sketch_dual.pdf}
\caption{\textbf{Example of dual encoding.}
An example of read is represented in the dual alphabet. The symbols
$\downarrow_{/j}^-$ ($j \geq 1$) represent a mismatch against the $-$
sequence, the symbols $\downarrow_{/j}^+$ ($j \geq 1$) represent a
mismatch against the $+$ sequence, and the symbol $\Downarrow$ represents
a mismatch against both. The index $i$ is the match length of the sequence
that is not mismatched. The symbolic $+$ and $-$ sequences are represented
below, where an open square stands for a match and a closed square stands
for a mismatch.}
\label{fig:dual}
\end{figure}

Let us assume that for each nucleotide, $a$ is the probability that the
read matches both sequences, $b$ is the probability that it matches only
the $+$ sequence, $c$ is the probability that it matches only the $-$
sequence and $d$ is the probability that it matches neither. Since there
are no other cases, we have $a+b+c+d=1$.

With these definitions, the weighted generating functions of the symbols
$\square$, $\downarrow_{/j}^-$, $\downarrow_{/j}^+$ ($j \geq 1$) and
$\Downarrow$ are $az$, $bz$, $cz$ and $dz$, respectively. The next
sections clarify how this is used to compute the weighted generating
functions of interest.


\subsection{Segments following $\Downarrow$}

After a $\Downarrow$ terminator, the match counter for both sequences is
reset; the following segment can thus have up to $\gamma-1$ matches for
any of the two sequences. Each match corresponds to the $\square$ symbol
with weighted generating function $az$. The terminators $\Downarrow$ and
$|$ have respective generating function $dz$ and $1$ (recall that the tail
symbol has size 0), so if the next terminator is $\Downarrow$ or $|$, the
segments have weighted generating functions $(1 + az + \ldots +
(az)^{\gamma-1})dz$ or $1 + az + \ldots + (az)^{\gamma-1}$, respectively.

If the next terminator is $\downarrow_{/j}^-$, there is a match of length
$j$ for the $+$ sequence, so the segment contains $j-1$ symbols $\square$
plus the terminator (which also matches the $+$ sequence). The weighted
generating function is thus $(az)^{j-1}bz$. By the same rationale, if the
next terminator is $\downarrow_{/j}^+$, the weighted generating function
of the segment is $(az)^{j-1}cz$.

The terminators $\downarrow_{/j}^+$ and $\downarrow_{/j}^-$ are disallowed
for $j \geq \gamma$ because this would create a seed for at least one of
the sequences.

\subsection{Segments following $\downarrow_{/i}^+$}

At a $\downarrow_{/i}^+$ terminator, the match length of the $+$ sequence
is 0 and the match length of the $-$ sequence is $i$. The next segment can
thus have up to $\gamma-1$ matches for the $+$ sequence, but only
$\gamma-i-1$ matches for the $-$ sequence, lowering the maximum size of
the segment. If the next terminator is $\Downarrow$ or $|$, the segments
have weighted generating functions $(1 + az + \ldots +
(az)^{\gamma-j-1})dz$ and $1 + az + \ldots + (az)^{\gamma-j-1}$,
respectively.

If the next terminator is $\downarrow_{/j}^-$, the weighted generating
function is $(az)^{j-1}bz$ as in the previous section. The difference is
that the terminators $\downarrow_{/j}^-$ are allowed only for $1 \leq j
\leq \gamma-i$, otherwise this would create seed for the $-$ sequence.

If the next terminator is $\downarrow_{/j}^+$, the situation is slightly
more complex because this imposes $i < j \leq \gamma-1$. Indeed,
there were already $i$ matches for the $-$ sequence at the terminator
$\downarrow_{/i}^+$, and there will be more at the end of the following
segment because it has no mismatch for the $-$ sequence. Taking this into
account, we see that the weighted generating function of those segments is
$(az)^{j-i-1}cz$ with $i < j \leq \gamma-1$.

\subsection{Segments following $\downarrow_{/i}^-$}

We can find the weighted generating functions by just reversing the $+$
and $-$ signs in the previous section. This way, we see that the weighted
generating function of the segments terminated by $\Downarrow$ or $|$ are
$(1 + az + \ldots + (az)^{\gamma-i-1})dz$ and $1 + az + \ldots +
(az)^{\gamma-i-1}$, respectively.

Likewise, the weighted generating function of the segments terminated by
$\downarrow_{/j}^+$ is $(az)^{j-1}cz$, where $1 \leq j \leq \gamma-i$; and
the weighted generating function of the segments terminated by
$\downarrow_{/j}^-$ is $(az)^{j-i-1}bz$ where $i < j \leq \gamma-1$.

\subsection{Transfer matrix}
\label{sec_transmat_skip}

We now have all the elements to specify the transfer matrix of reads with
no seed for either sequence. Recall that $a$ is the probability of a
double match, $b$ is the probability of a mismatch only against the $-$
sequence, $c$ is the probability of a mismatch only against the $+$
sequence and $d$ is the probability of a double mismatch. For notational
convenience, we define
\begin{equation}
% These expressions are not needed for reference in the text, but
% they are still numbered so that the code can reference to it.
\begin{gathered}
r_i^+(z) = (az)^i cz, \\
r_i^-(z) = (az)^i bz, \\
R_i(z) = \big( 1 + az + \ldots + (az)^i \big) dz, \\
F_i(z) = 1 + az + \ldots + (az)^i.
\end{gathered}
\end{equation}

With these notations, the information from the previous sections can be
summarized in the transfer matrix $\tilde{M}_0(z)$ equal to
\begin{equation*}
\begin{blockarray}{ccccccccc}
   & \scriptstyle{\Downarrow} & \scriptstyle{\downarrow_{/1}^+} & 
    \ldots & \scriptstyle{\downarrow_{\gamma-1}^+} &
    \scriptstyle{\downarrow_{/1}^-} & \ldots &
    \scriptstyle{\downarrow_{/\gamma-1}^-} & \scriptstyle{|} \\
\begin{block}{c[cccccccc]}
\scriptstyle{\Downarrow} & R_{\gamma-1}(z)  & r_0^+(z) & \ldots &
    r_{\gamma-2}^+(z) & r_0^-(z) & \ldots & r_{\gamma-2}^-(z) &
    F_{\gamma-1}(z) \\
\scriptstyle{\downarrow_{/1}^+} & R_{\gamma-2}(z) & & & & & & &
    F_{\gamma-2}(z) \\
\scriptstyle{\downarrow_{/2}^+} & R_{\gamma-3}(z) & & & & & & &
    F_{\gamma-3}(z) \\
\vdots & \vdots & & \tilde{A}(z) & & & \tilde{B}_0(z) & & \vdots \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & R_0(z) & & & & & & & F_0(z) \\
\scriptstyle{\downarrow_{/1}^-} & R_{\gamma-2}(z) & & & & & & &
    F_{\gamma-1}(z) \\
\scriptstyle{\downarrow_{/2}^+} & R_{\gamma-3}(z) & & & & & & &
    F_{\gamma-2}(z) \\
\vdots & \vdots & & \tilde{C}_0(z) & & & \tilde{D}(z) & & \vdots \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & R_0(z) & & & & & & & F_0(z) \\
\scriptstyle{|} & 0 & 0 & \ldots & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
where $\gamma$ is the minimum seed length, and where $\tilde{A}(z)$,
$\tilde{B}_0(z)$, $\tilde{C}_0(z)$ and $\tilde{D}(z)$ are matrices of
dimensions $(\gamma-1) \times (\gamma-1)$ that are defined as
\begin{equation*}
\tilde{A}(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^+} & \scriptstyle{\downarrow_{/2}^+} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^+} &
    \scriptstyle{\downarrow_{/\gamma-1}^+} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^+} & 0 & r_0^+(z) & \ldots &
    r_{\gamma-4}^+(z) & r_{\gamma-3}^+(z) \\
\scriptstyle{\downarrow_{/2}^+} & 0 & 0 & \ldots &
    r_{\gamma-5}^+(z) & r_{\gamma-4}^+(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^+} & 0 & 0 & \ldots & 0 & r_0^+(z) \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
\begin{equation*}
\tilde{B}_0(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^-} & \scriptstyle{\downarrow_{/2}^-} &
   \ldots & \scriptstyle{\downarrow_{/\gamma-2}^-} &
   \scriptstyle{\downarrow_{/\gamma-1}^-} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^+} & r_0^-(z) & r_1^-(z) & \ldots &
    r_{\gamma-3}^-(z) & r_{\gamma-2}^-(z) \\
\scriptstyle{\downarrow_{/2}^+} & r_0^-(z) & r_1^-(z) & \ldots &
    r_{\gamma-3}^-(z) & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^+} & r_0^-(z) & r_1^-(z) &
    \ldots & 0 & 0 \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & r_0^-(z) & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
\begin{equation*}
\tilde{C}_0(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^+} & \scriptstyle{\downarrow_{/2}^+} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^+} &
    \scriptstyle{\downarrow_{/\gamma-1}^+} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    r_{\gamma-3}^+(z) & r_{\gamma-2}^+(z) \\
\scriptstyle{\downarrow_{/2}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    r_{\gamma-3}^+(z) & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    0 & 0 \\
\scriptstyle{\downarrow_{/\gamma-1}^-} & r_0^+(z) & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
\begin{equation*}
\tilde{D}(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^-} & \scriptstyle{\downarrow_{/2}^-} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^-} &
    \scriptstyle{\downarrow_{/\gamma-1}^-} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^-} & 0 & r_0^-(z) & \ldots &
    r_{\gamma-4}^-(z) & r_{\gamma-3}^-(z) \\
\scriptstyle{\downarrow_{/2}^-} & 0 & 0 & \ldots &
    r_{\gamma-5}^-(z) & r_{\gamma-4}^-(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^-} & 0 & 0 & \ldots & 0 & r_0^-(z) \\
\scriptstyle{\downarrow_{/\gamma-1}^-} & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray}.
\end{equation*}

As before, the term of interest is the top right entry of
$\tilde{M}_0(z)\cdot(I-\tilde{M}_0(z))^{-1}$. To see why, observe that
every read can be prepended by $\Downarrow$-segments and only by those
(every other terminator would imply that one of the two sequences has a
nonzero match size at the start of the read). Thus reads are precisely the
sequences of segments that can follow the symbol $\Downarrow$ and that are
terminated by a tail, the weighted generating function of which is the top
right entry of the matrix.

$\tilde{M}_0(z)$ is too complex to compute a closed expression of
$\tilde{M}_0(z)\cdot(I-\tilde{M}_0(z))^{-1}$. It is easier to proceed as
in section~\ref{sec:example_skip} and to compute the powers of
$\tilde{M}_0(z)$ up to a finite value. This is done once again using the
arithmetic of truncated polynomials. Since each segment except the tail
contains a mismatch against at least one sequence, the top right entry of
$\tilde{M}_0(z)^{s+1}$ is the weighted generating function of reads that
contain $s$ mismatches (where doule mismatches count as one). We thus
define $\tilde{p}$ as the upper bound on the probability of a mismatch,
\textit{i.e.} $\tilde{p} = \max\{b,c,d\}$. The updated formula
(\ref{eq:bound}) now gives an upper bound of the probability that a read
of size $k$ contains $s$ or more mismatches as
\begin{equation*}
Pr(X \geq s) \leq \exp \left( (s-k)\log \frac{k-s}{k(1-\tilde{p})} -s\log
\frac{s}{k\tilde{p}} \right).
\end{equation*}

With this upper bound, we can compute the terms of the matrix partial sums
$\tilde{M}_0(z) + \tilde{M}_0(z)^2 + \ldots + \tilde{M}_0(z)^s$ until the
neglected terms become negligible, \textit{i.e.} until we can be sure that
the coefficient of interest $a_k$ is accurate to within chosen
$\varepsilon$.

Now returning to the problem of computing $P(\overline{S}_0 \cap
\overline{S}_1)$, the $+$ sequence is interpreted as the target and the
$-$ sequence as the duplicate. Based on the assumptions of the error model
presented in section~\ref{sec:error}, this implies that $a =
(1-p)(1-\mu)$, $b = (1-p)\mu$, $c = p\mu/3$, and $d = p(1-\mu/3)$.

With these values, we can fully specify the matrix $\tilde{M}_0(z)$, and
compute its powers until the estimate of the coefficient of interest $a_k$
is accurate enough, finally giving a numerical value for $P(\overline{S}_0
\cap \overline{S}_1)$.


\subsection{Illustration}
\label{sec:illdual}

We illustrate the strategy delineated above for reads of size $k=50$
sequenced with an instrument with error rate $p=0.01$, when using exact
seeds of size $\gamma=19$.

\begin{figure}[h]
\centering
\includegraphics[scale=0.65]{curves_exact.pdf}
\caption{\textbf{Off-target seeding probabilities (exact seeds).} The
surfaces show the probability that seeding is off-target as a function of
the divergence rate $\mu$ and of the number $N$ of duplicates. The results
are shown for exact seeds of size $\gamma=19$ and for reads of size $k=50$
nucleotides sequenced with an error rate $p=0.01$. The divergence rate
$\mu$ is defined as the probability that a given duplicate differs from
the target at any given position. Note the factor 1000 in the scale of the
z-axis.}
\label{fig:curves_exact}
\end{figure}

Figure~\ref{fig:curves_exact} shows the result for a number of duplicates
$N$ from 1 to 10 and for a divergence rate $\mu$ from 0 to 0.20. The first
observation is that the probability that seeding is off-target increases
with $N$. This is also clear from expression (\ref{eq:Poff}). This can
also be understood intuitively because the probability of not seeding the
target is fixed and the probability of having an empty candidate set
decreases as $N$ increases. As a result the probability that the candidate
set contains only invalid candidates increases with $N$.

The second observation is that there exists a ``worst'' value of $\mu$
situated around 0.070. When $\mu$ is much smaller, the duplicates tend to
be exactly identical to the target, making it impossible that there is a
seed for a duplicate but no seed for the target. When $\mu$ is much
larger, the duplicates are far from the target and they are unlikely to be
in the candidate set at all. In expression (\ref{eq:Poff}), the only term
that depends on $\mu$ is $P(\overline{S}_0 \cap \overline{S}_1)$, and it
is clear that the minimum of expression (\ref{eq:Poff}) corresponds to the
maximum of $P(\overline{S}_0 \cap \overline{S}_1)$. This is why the worst
value of $\mu$ is the same for every $N$.


\section{Off-target skip seeds}
\label{sec_offskip}

To compute the probability that the seeding process is off-target when
using skip seeds, we observe that the logic of section~\ref{sec:offexact}
can be transposed with few modifications. In particular, the probability
can be computed through expression (\ref{eq:Poff}), where $S_0$ is the
event that the read has a \emph{skip} seed for the target (instead of an
exact seed) and $S_1$ is the event that the read has a \emph{skip} seed
for the first duplicate (instead of an exact seed).

We have already seen how to compute $P(\overline{S}_0)$ in
section~\ref{sec:example_skip}, we now need to find a way to compute
$P(\overline{S}_0 \cap \overline{S}_1)$ when using skip seeds.

\subsection{The skip dual encoding}

As before, we recode the reads in a specialized alphabet. We define the
skip-$n$ dual alphabet as $\tilde{\mathcal{A}}_n = \{\square, *, |,
\Downarrow_0, \Downarrow_1, \Downarrow_2, \ldots, \Downarrow_n,
\downarrow^-_{/1}, \downarrow^-_{/2}, \ldots, \downarrow^+_{/1},
\downarrow^+_{/2}, \ldots\}$. The symbols $\square$, $|$,
$\downarrow^-_{/j}$ and $\downarrow^+_{/j}$ ($j \geq 1$) have the same
meaning as in the dual alphabet of section~\ref{sec:dual}, \textit{i.e.}
the $\square$ symbol stands for a double match, the $|$ terminator marks
the end of the read, the $\downarrow^-_{/j}$ symbol indicates a mismatch
against the $-$ sequence with a match length of size $j$ for the $+$
sequence, and conversely the $\downarrow^+_{/j}$ symbol indicates a
mismatch against the $+$ sequence with a match of length $j$ for the $-$
sequence. The symbols $\Downarrow_j$ ($0 \leq j \leq n$) indicate that
both sequences have match length 0 and that the next non-skipped position
is $j$ nucleotides further. The symbol $*$ indicates that it does not
matter whether the nucleotide is a match or a mismatch, as we will explain
below.
 
Figure~\ref{fig:skip_dual} shows the read from Figure~\ref{fig:dual}
represented in the skip-3 dual encoding. It is important to note several
differences with Figure~\ref{fig:dual}. The first is that the symbols
$\Downarrow_j$ ($0 \leq j \leq n$) are not always associated with double
mismatches. For instance, the symbol $\Downarrow_0$ on the right side of
the read corresponds to a mismatch for the $+$ sequence only. This happens
whenever the $+$ and the $-$ sequences are mismatched in the same interval
between non-skipped positions (the mismatches do not need to be on the
same nucleotide).

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{sketch_skip_dual.pdf}
\caption{\textbf{Example of skip dual encoding.}
The read of Figure~\ref{fig:dual} is represented in the skip dual alphabet.
The vertical bars above the read indicate non-skipped positions. The
symbols $\downarrow_{/j}^-$ and $\downarrow_{/j}^+$ ($j \geq 1$) have the
same meaning as in the dual alphabet. The symbols $\Downarrow_j$ indicate
that both sequences have match length 0 and that the next non-skipped
position is located $j$ nucleotides downstream. Other features are as in
Figure~\ref{fig:dual}.}
\label{fig:skip_dual}
\end{figure}

Also observe that the symbol $\Downarrow_1$ is followed by a $*$ symbol,
indicating that it does not matter whether the nucleotide is a match or a
mismatch for any of the two sequences. After the $\Downarrow_1$ symbol,
both sequences have match length 0 and one has to ``wait'' for a potential
new seed one nucleotide further downstream. As in appendix~\ref{app_Mn},
the $\Downarrow_j$ symbols are followed by $j$ symbols $*$, unless the end
of the read comes before the next non-skipped position. After a sequence
of $*$ symbols, the read is either finished or at a non-skipped position.
In the second case, the is in the same state as after a $\Downarrow_0$
symbol, so we can consider that the $*$ symbol allows the terminators
$\Downarrow_j$ ($1 \leq j \leq n$) to just ``fast forward'' to either
$\Downarrow_0$ or $|$, as shown in appendix~\ref{app_Mn}.

As in the previous section, let $a$, $b$, $c$ and $d$ denote the
probabilities of a double match, a mismatch against $-$, a mismatch
against $+$ and a double mismatch, respectively. With these definitions,
the weighted generating functions of the symbols $\square$,
$\downarrow_{/j}^-$ and $\downarrow_{/j}^+$ ($j \geq 1$) are $az$, $bz$
and $cz$, respectively. The weighted generating function of the $*$ symbol
is $z$, and that of the symbols $\Downarrow_j$ ($0 \leq j \leq n$) will be
worked out in the sections below.


\subsection{Segments following $\Downarrow_i$ ($1 \leq i \leq n$)}

A $\Downarrow_i$ terminator is followed by up to $i$ symbols $*$. If there
are fewer than $i$ symbols $*$, the read is finished so the segment must
be a tail. Recall that the weighted generating function of the $|$
terminator is 1, so the weighted generating function of tail segments is
$1 + z + \ldots + z^{i-1}$.

If there are $i$ symbols $*$, the sequence ends at a non-skipped position,
\textit{i.e.} in the same state as after a $\Downarrow_0$ terminator. This
is not a segment proper, because there is no terminator, but in the
transfer matrix the symbols $\Downarrow_i$ ($1 \leq i \leq n$) project
directly to the symbol $\Downarrow_0$ with weighted generating function
$z^i$.

\subsection{Segments following $\Downarrow_0$}

After a $\Downarrow_0$ symbol, all the counters are reset as in the
beginning of the read. If the next terminator is $|$, the segment is a
tail and we only have to make sure that it contains fewer than $\gamma$
symbols $\square$, otherwise this would create a seed. The weighted
generating function of tail segments following $\Downarrow_0$ is thus $1 +
qz + \ldots + (qz)^{\gamma-1}$.

If the next terminator is a $\downarrow_{/j}^-$ symbol ($j \geq 1$), the
segment is a match of size $j$ for the $+$ sequence. This imposes $j <
\gamma$ otherwise the segment would create a seed. Such segments consist
of $j-1$ symbols $\square$ followed by the terminator, so their weighted
generating function is $(az)^{j-1}bz$ with $1 \leq j < \gamma$.

Conversely, if the next terminator is a $\downarrow_{/j}^+$ symbol ($j
\geq 1$), we can apply the same rationale to see that the weighted
generating function is $(az)^{j-1}cz$, where $1 \leq j < \gamma$.

Finally, if the next terminator is a $\Downarrow_j$ symbol ($0 \leq j \leq
n$), we must not only make sure that the segment contains fewer than
$\gamma$ symbols $\square$, but also keep track of the position of the
next non-skipped position (stored in index $j$). Here we can follow
verbatim the rationale of section~\ref{sec:example_skip} where we replace
the probability of a match (previously $q$) by that of a double match (now
$a$), and the probability of a mismatch (previously $p$) by that a double
mismatch (now $d$). Replacing the symbols in expression (\ref{eq_H}), we
see that the weighted generating function is $(az)^x \cdot \big( 1 +
(az)^{n+1} + \ldots + (az)^{(n+1)m} \big) dz$, where  $x = n-j
\modulo{n+1}$ and $m = \left\lfloor (\gamma-1-x) / (n+1) \right\rfloor$.


\subsection{Segments following $\downarrow_{/i}^-$}

At a $\downarrow_{/i}^-$ terminator ($i \geq 1$), the read contains a
match of length $i$ for the $+$ sequence. If the next segment is a tail,
we must make sure that the match length for the $+$ sequence does not
exceed $\gamma-1$. This means that we can have up to $\gamma-i-1$ symbols
$\square$ and thus that the weighted generating function of the tail
segments is $1 + (qz) + \ldots + (qz)^{\gamma-i-1}$.

If the next terminator is a $\downarrow_{/j}^-$ symbol, we must have $j >
i$ because there is no mismatch against the $+$ sequence. In this case, we
must only make sure that the total match length for the $+$ sequence
remains lower than $\gamma$. Such segments contain $j-i-1$ symbols
$\square$ followed by the terminator so their weighted generating function
is $(qz)^{i-j-1}bz$ with $i < j \leq \gamma-1$.

For the last two types of terminators, we must pay attention to the fact
that in general, a mismatch against $+$ that follows a mismatch against
$-$ can be represented by either a $\Downarrow_j$ symbol ($0 \leq j \leq
n$) or a $\downarrow_{/j}^+$ symbol ($j \geq 1$). The terminator is
$\Downarrow_j$ if the two mismatches are within the same interval between
non-skipped positions because both sequences locally have match length 0.
If the mismatch against $+$ is in another interval, the terminator is
$\downarrow_{/j}^+$ because in that case the $-$ sequence has a positive
match length. For now, bear in mind that a mismatch against the $+$
sequence only can produce a $\Downarrow_j$ terminator ($0 \leq j \leq n$),
this will be important later.

If the next terminator is $\downarrow_{/j}^+$ ($j \geq 1$), then it must
be separated from the  preceding $\downarrow_{/i}^-$ terminator by a
non-skipped position, which imposes a lower bound on the size of the
segment. Since at the $\downarrow_{/i}^-$ terminator the match length for
$+$ was $i$, there must be a non-skipped position $i$ nucleotides before.
The number of nucleotides from the $\downarrow_{/i}^-$ terminator to the
next non-skipped position is thus $y = -i \modulo{n+1}$, so the minimum
segment length is $y+1$ There is also an upper bound on the size of the
segment because the match length for the $+$ sequence cannot become higher
than $\gamma-1$, imposing the length to be lower than $\gamma-i$. The
shortest segment is terminated by $\downarrow_{/1}^+$, and the longest by
$\downarrow_{/{\gamma-y-i}}^+$. Finally, the weighted generating function
of segments terminated by $\downarrow_{/j}^+$ following the
$\downarrow_{/i}^-$ terminator is $(az)^{y+j-1}cz$ with $1 \leq j \leq
\gamma-y-i$. Note that for some value of $i$ and $y$, no $j$ can satisfy
the last inequality.

Finally, if the next terminator is $\Downarrow_j$ ($0 \leq j \leq n$) we
have to distinguish two cases, depending on whether the segment ends with
a double mismatch, or with a single mismatch against the $+$ sequence. For
the first case we can apply the rationale of
section~\ref{sec:example_skip}. Recall that the index $j$ indicates the
number of nucleotides until the next non-skipped position. Let $\ell_0$ be
the length of the shortest possible segment. The lengths of the other
segments are of the form $\ell_0 + n+1, \ldots, \ell_0 + m(n+1)$, where
the integer $m$ must be chosen so that the segment does not create a seed.
At the $\downarrow_{/i}^-$ terminator, there is a match of length $i$ for
the $+$ sequence so $m$ is the largest integer such that $i+\ell_0+m(n+1)
< \gamma$, \textit{i.e.} $m = \lfloor(\gamma-i-\ell_0) / (n+1)\rfloor$.

The $\downarrow_{/i}^-$ terminator is $y = -i \modulo{n+1}$ nucleotides
before the next non-skipped position so the shortest segment has length
$\ell_0 = y-j$ if $y > j$, and $n+1-j+y$ otherwise. This is equivalent to
defining $\ell_0$ as $x+1$ where $x$ is the number of $\square$ symbols in
the shortest segment, \textit{i.e.} $x=-i-j-1 \modulo{n+1}$. Summing the
weighted generating functions of the individual segments, we find
$(az)^x(1+(az)^{n+1} + \ldots + (az)^{m(n+1)})dz$.

The last remaining issue is that a mismatch against the $+$ sequence only
can produce a $\Downarrow_j$ terminator. This happens when the preceding
$\downarrow_{/i}^-$ terminator is not separated from the mismatch by a
non-skipped position (in this case both sequences locally have match
length 0). The $\downarrow_{/i}^-$ terminator is located $y$ nucleotides
before the next non-skipped position, so if the terminator is from
$\Downarrow_0$ to $\Downarrow_{y-1}$ we need to add the term
$(az)^xbz$ to the previous weighted generating function. In
conclusion, the weighted generating function of segments terminated by
$\Downarrow_j$ is $(az)^x(1+(az)^{n+1} + \ldots + (az)^{m(n+1)})dz +
\delta^+_{i,j}(z)$, where $\delta^+_{i,j}(z) = (az)^xbz$ if $j < y$ and
$0$ otherwise.


\subsection{Segments following $\downarrow_{/i}^+$}

We can find the weighted generating functions by just reversing the $+$
and $-$ signs in the previous section. This way we can see that the
weighted generating function of tail segments is $1 + (qz) + \ldots +
(qz)^{\gamma-i-1}$.

Likewise, the weighted generating function of segments terminated by
$\downarrow_{/j}^+$ is $(qz)^{i-j-1}bz$ with $i < j \leq \gamma-1$.

The weighted generating function of segments terminated by
$\downarrow_{/j}^-$ is $(az)^{y+j-1}dz$ with $y = -i \modulo{n+1}$ and $1
\leq j \leq \gamma-y-i$.

Finally, the weighted generating function of segments terminated by
$\Downarrow_j$ is $(az)^x(1+(az)^{n+1} + \ldots + (az)^{m(n+1)})dz +
\delta^-_{i,j}(z)$, where $\delta^-_{i,j}(z) = (az)^xcz$ if $j < y$ and
$0$ otherwise.


\subsection{Transfer matrix}

We now have all the elements to specify the transfer matrix of reads with
no skip-$n$ seed for either sequence. Recall that $n$ is the number of
skipped nucleotides, $\gamma$ is the minimum seed length, $a$ is the
probability of a double match, $b$ is the probability of a mismatch
against the $-$ sequence only, $c$ is the probability of a mismatch
against the $+$ sequence only and $d$ is the probability of a double
mismatch. For notational convenience we define
\begin{eqnarray}
\label{eq_N}
N_i(z) &=& 1+z+\ldots+z^i, \\
W_j(z) &=& (az)^x \big( 1 + (az)^{n+1} + \ldots +
  (az)^{(n+1)m} \big) dz, \\
  \notag
  &\quad& \text{where } x = -j-1 \modulo{n+1},
  \text{ and } m = \left\lfloor
  \frac{\gamma-1-x}{n+1} \right\rfloor, \\
U_{i,j}(z) &=& (az)^x
  \big( 1 + (az)^{n+1} + \ldots + (az)^{(n+1)m} \big)dz +
\begin{cases}
  bz\cdot(az)^x \text{ if } j < y, \\
  0 \text{ otherwise}
\end{cases} \\
  \notag
  &\quad& \text{where } x = -i-j-1 \modulo{n+1},
  y = -i \modulo{n+1}, \\
  \notag
  &\quad& \text{and } m = \left\lfloor \frac{\gamma-1-i-x}{n+1}
    \right\rfloor, \\
V_{i,j}(z) &=& (az)^x 
  \big( 1 + (az)^{n+1} + \ldots + (az)^{(n+1)m} \big)dz +
\begin{cases}
  cz\cdot(az)^x \text{ if } j \leq x, \\
  0 \text{ otherwise}
\end{cases} \\
  \notag
  &\quad& \text{ where } x = -i-j-1 \modulo{n+1},
  m = \left\lfloor \frac{\gamma-1-i-x}{n+1} \right\rfloor.
\end{eqnarray}

With these notations, the information from the previous sections can be
summarized in the transfer matrix $\tilde{M}_n(z)$ equal to

\pagebreak

\begin{equation*}
\rotatebox{90}{$
\begin{blockarray}{cccccccccccc}
   & \scriptstyle{\Downarrow_0} & \scriptstyle{\Downarrow_1} &
   \ldots & \scriptstyle{\Downarrow_n} &
    \scriptstyle{\downarrow_{/1}^+} & 
    \ldots & \scriptstyle{\downarrow_{\gamma-1}^+} &
    \scriptstyle{\downarrow_{/1}^-} & \ldots &
    \scriptstyle{\downarrow_{/\gamma-1}^-} & \scriptstyle{|} \\
\begin{block}{c[ccccccccccc]}
\scriptstyle{\Downarrow_0} & W_0(z) & W_1(z) & \ldots & W_n(z) &
    r_0^+(z) & \ldots & r_{\gamma-2}^+(z) & r_0^-(z) & \ldots &
    r_{\gamma-2}^-(z) & F_{\gamma-1}(z) \\
\scriptstyle{\Downarrow_1} & z  & 0 & \ldots &
  0 & 0 & \ldots & 0 & 0 & \ldots & 0 & N_0(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \ddots &
  \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\Downarrow_n} & z^n & 0 & \ldots &
  0 & 0 & \ldots & 0 & 0 & \ldots & 0 & N_{n-1}(z) \\
\scriptstyle{\downarrow_{/1}^+} & U_{1,0}(z) & U_{1,1}(z) & \ldots &
  U_{1,n}(z) & & & & & & & F_{\gamma-2}(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & & \tilde{A}(z) & & &
  \tilde{B}_n(z) & & \vdots \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & U_{\gamma-1,0}(z) &
  U_{\gamma-1,1}(z) & \ldots & U_{\gamma-1,n}(z) & & & & & & & F_0(z) \\
\scriptstyle{\downarrow_{/1}^-} & V_{1,0}(z) & V_{1,1}(z) & \ldots &
    V_{1,n}(z) & & & & & & & F_{\gamma-2}(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & & \tilde{C}_n(z) &
  & & \tilde{D}(z) & & \vdots \\
\scriptstyle{\downarrow_{/\gamma-1}^-} & V_{\gamma-1,0}(z) &
    V_{\gamma-1,1}(z) & \ldots & V_{\gamma-1,n}(z) & & &
    & & & & F_0(z) \\
\scriptstyle{|} & 0 & 0 & \ldots & 0 & 0 & \ldots & 0 & 0 &
  \ldots & 0 & 0 \\
\end{block}
\end{blockarray}.
$}
\end{equation*}

\pagebreak

The matrices $\tilde{A}(z)$ and $\tilde{C}(z)$ in the expression of
$\tilde{M}_n(z)$ are the same as in section~\ref{sec:dual}. They are
reproduced here for convenience.
\begin{equation*}
\tilde{A}(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^+} & \scriptstyle{\downarrow_{/2}^+} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^+} &
    \scriptstyle{\downarrow_{/\gamma-1}^+} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^+} & 0 & r_0^+(z) & \ldots &
    r_{\gamma-4}^+(z) & r_{\gamma-3}^+(z) \\
\scriptstyle{\downarrow_{/2}^+} & 0 & 0 & \ldots &
    r_{\gamma-5}^+(z) & r_{\gamma-4}^+(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^+} & 0 & 0 & \ldots & 0 & r_0^+(z) \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
\begin{equation*}
\tilde{C}_0(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^+} & \scriptstyle{\downarrow_{/2}^+} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^+} &
    \scriptstyle{\downarrow_{/\gamma-1}^+} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    r_{\gamma-3}^+(z) & r_{\gamma-2}^+(z) \\
\scriptstyle{\downarrow_{/2}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    r_{\gamma-3}^+(z) & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^-} & r_0^+(z) & r_1^+(z) & \ldots &
    0 & 0 \\
\scriptstyle{\downarrow_{/\gamma-1}^-} & r_0^+(z) & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray}.
\end{equation*}


The matrices $\tilde{B}_n(z)$ and $\tilde{C}_n(z)$ are defined as
\begin{equation*}
\tilde{B}_n(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^-} & \scriptstyle{\downarrow_{/2}^-} &
   \ldots & \scriptstyle{\downarrow_{/\gamma-2}^-} &
   \scriptstyle{\downarrow_{/\gamma-1}^-} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^+} & s_{1,1}(z) & s_{1,2}(z) &
    \ldots & s_{1,\gamma-2}(z) & s_{1,\gamma-1}(z) \\
\scriptstyle{\downarrow_{/2}^+} & s_{2,1}(z) & s_{2,2}(z) &
    \ldots & s_{2,\gamma-2}(z) & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^+} & s_{\gamma-2,1}(z) &
    s_{\gamma-2,2}(z) & \ldots & 0 & 0 \\
\scriptstyle{\downarrow_{/\gamma-1}^+} & s_{\gamma-1,1}(z) & 0 &
    \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
\begin{equation*}
\tilde{C}_n(z) = 
\begin{blockarray}{cccccc}
   & \scriptstyle{\downarrow_{/1}^+} & \scriptstyle{\downarrow_{/2}^+} &
    \ldots & \scriptstyle{\downarrow_{/\gamma-2}^+} &
    \scriptstyle{\downarrow_{/\gamma-1}^+} \\
\begin{block}{c[ccccc]}
\scriptstyle{\downarrow_{/1}^-} & t_{1,1}(z) & t_{1,2}(z) &
    \ldots & t_{1,\gamma-2}(z) & t_{1,\gamma-1}(z) \\
\scriptstyle{\downarrow_{/2}^-} & t_{2,1}(z) & t_{2,2}(z) &
    \ldots & t_{2,\gamma-2}(z) & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\scriptstyle{\downarrow_{/\gamma-2}^-} & t_{\gamma-2,1}(z) &
    t_{\gamma-2,2}(z) & \ldots & 0 & 0 \\
\scriptstyle{\downarrow_{/\gamma-1}^-} & t_{\gamma-1,1}(z) &
    0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation*}
with
\begin{eqnarray*}
s_{i,j} &=&
  \begin{cases}
  cz \cdot (az)^{y+j-1} &\text{ if } i+j+y \leq \gamma \\
  0                     &\text{ otherwise,}
  \end{cases} \\
t_{i,j} &=&
  \begin{cases}
  bz \cdot (az)^{y+j-1} &\text{ if } i+j+y \leq \gamma \\
  0                     &\text{ otherwise,}
  \end{cases} \\
  \text{where } y &=& -i \modulo{n+1}, \text{ in both cases.} \\
\end{eqnarray*}

Now returning to the problem of computing $P(\overline{S}_0 \cap
\overline{S}_1)$, the $+$ sequence is interpreted as the target and the
$-$ sequence as the duplicate. Based on the assumptions of the error model
presented in section~\ref{sec:error}, this implies that $a =
(1-p)(1-\mu)$, $b = (1-p)\mu$, $c = p\mu/3$, and $d = p(1-\mu/3)$.

The computation is performed as described in section~\ref{sec:dual}. We
compute the successive powers of $\tilde{M}_n(z)$ in the arithmetic of
truncated polynomials and stop the iterations using the same criterion.
The only modification is that the top right term of $\tilde{M}_n(z)^{s+1}$
is not the weighted generating function of reads with $s$ mismatches
(where double mismatches count as one). The reason is that the sequences
of $*$ symbols are not terminated by a mismatch. However, that can be at
most one sequence of $*$ symbols for each mismatch or double mismatch, so
the reads described by the top right term of $\tilde{M}_n(z)^{s+1}$ have
at least $\lfloor s/2 \rfloor$ mismatches.

We thus define $\tilde{p}$ as the upper bound on the probability of a
mismatch, \textit{i.e.} $\tilde{p} = \max\{b,c,d\}$ and use the updated
formula (\ref{eq:bound}) from section~\ref{sec_transmat_skip}
\begin{equation*}
Pr(X \geq s) \leq \exp \left( (s-k)\log \frac{k-s}{k(1-\tilde{p})} -s\log
\frac{s}{k\tilde{p}} \right).
\end{equation*}

With this upper bound, we can compute the terms of the matrix partial sums
$\tilde{M}_0(z) + \tilde{M}_0(z)^2 + \ldots + \tilde{M}_0(z)^{2s+1}$ until
the neglected terms become negligible, \textit{i.e.} until we can be sure
that the coefficient of interest $a_k$ is accurate to within chosen
$\varepsilon$.

\begin{remark}
Observe that when $n=0$ the matrix $\tilde{M}_n(z)$ is identical to the
matrix $\tilde{M}_0(z)$ of section~\ref{sec:dual}, again consistent with
the fact that exact seeds are skip-$0$ seeds. The same applies to
$\tilde{B}_n(z)$ and $\tilde{C}_n(z)$.
\end{remark}


% XXX The following algorithm works but it is not very useful    XXX
% XXX because it is substantially slower than the WGF method.    XXX
% XXX It has been used to check the accuracy of the calculations XXX
% XXX but there is no reason to put it in the manuscript.        XXX

%\begin{algorithm}[H]
%\label{alg:mcmcskip}
%\SetAlgoLined
%\KwResult {Sample a read at random. Return 1 if the read contains a
%good seed, otherwise return 0.}
%  $\lambda \leftarrow 0$ \Comment*[r]{Current read size.}
%  $s_+ \leftarrow 0$ \Comment*[r]{Current + match size.}
%  $s_- \leftarrow 0$ \Comment*[r]{Current - match size.}
%  \While {$\lambda < k$}{
%    $i \leftarrow geom(1-a)-1$
%                \Comment*[r]{Double-match nucleotides.}
%    \If {$i \geq k-\lambda$}{
%      $s_+ \leftarrow s_+ + k-\lambda$ \;
%      $s_- \leftarrow s_- + k-\lambda$ \;
%      break \;
%    }
%    $s_+ \leftarrow s_+ + i$ \;
%    $s_- \leftarrow s_- + i$ \;
%    \If {$s_+ \geq \gamma$ or $s_- \geq \gamma$}{
%      return 1 \;
%    }
%    $\lambda \leftarrow \lambda + i+1$ \;
%    $r \leftarrow rand(0,1-a)$
%                \Comment*[r]{Uniform random number.}
%    \uIf {$r < b$}{
%      $s_+ \leftarrow s_++1$ \;
%      $s_- \leftarrow -(-\lambda \mod n+1)$ \;
%    }\uElseIf{$r < b+c$}{
%      $s_+ \leftarrow -(-\lambda \mod n+1)$ \;
%      $s_- \leftarrow s_-+1$ \;
%    }\Else{
%      $s_+ \leftarrow -(-\lambda \mod n+1)$ \;
%      $s_- \leftarrow -(-\lambda \mod n+1)$ \;
%    }
%}
%\eIf {$s_+ \geq \gamma$ or $s_- \geq \gamma$}{
%  return 1 \;
%}{
%  return 0 \;
%}
%\end{algorithm}


\subsection{Illustration}
\label{sec:illskipdual}

We illustrate the strategy delineated above using the same settings as in
section~\ref{sec:illdual} (reads of length $k=50$, probability of
sequencing error $p=0.01$ and seeds of minimum size $\gamma=19$), except
that we replace exact seeds by skip-5 and skip-9 seeds.

\begin{figure}[h]
\centering
\includegraphics[scale=0.47]{curves_skip.pdf}
\caption{\textbf{Off-target seeding probabilities (skip seeds).}
The surfaces show the probability that seeding is off-target for skip-5
and skip-9 seeds of size $\gamma=19$. Read size and error rate are the
same as in Figure~\ref{fig:curves_exact}, \textit{i.e.} $k=50$ and
$p=0.01$. The divergence rate $\mu$, defined as the probability that a
given duplicate differs from the target at any given position. Note the
factor 1000 in the scale of the z-axis.}
\label{fig:curves_skip}
\end{figure}

Figure~\ref{fig:curves_skip} shows the result for a number of duplicates $N$
from 1 to 10 and for a divergence rate $\mu$ from 0 to 0.20. The surfaces
have the same general aspect as in Figure~\ref{fig:curves_exact}. The
probability that seeding is off-target increases with $N$ and there is
again a  worst value of $\mu$, because the maximum of $P(\overline{S}_0
\cap \overline{S}_1)$ minimizes expression (\ref{eq:Poff}) for every value
of $N$. However, those values of $\mu$ are not constant (they are
approximately 0.065 and 0.060 for skip-5 and skip-9 seeds, respectively).

Importantly, Figure~\ref{fig:curves_skip} reveals that skipping 5
nucleotides increases the chances that seeding is off-target by a factor
approximately 1.5, and skipping 9 nucleotides by a factor approximately
1.8 (compare with Figure~\ref{fig:curves_exact}). Skipping nucleotides
seems to have little effect, but this is not a general conclusion. Indeed,
skipping nucleotides decreases the probability of on-target seeding
(skipping positions implies fewer on-target seeds) but increases the
probability of null seeding (skipping positions implies fewer seeds
overall), so the effects must be evaluated on a case-by-case basis.
Skipping nucleotides can even decrease the probability that seeding is
off-target. Concretely, for exact seeds of size $\gamma=19$ in reads of
size $k=50$ with $N=10$ duplicates at divergence $\mu=0.1$ with a
sequencing error $p=0.1$, the probability of off-target seeding is
approximately 0.178 with exact seeds and 0.035 with skip-9 seeds, showing
skipping nucleotides can have different effects.

This kind of information is critical for choosing the best seeding
strategy. Yet, the off-target seeding probability is not the only
criterion. Equally important considerations are the probability of
on-target seeding, the computational resources required to implement a
particular seeding strategy and other sources existing of mapping errors
(see discussion in section~\ref{sec:truevsbest}). The benefit of a theory
to compute seeding probabilities is to have access to this knowledge.


\section{Off-target MEM seeds}
\label{sec_offMEM}

MEM seeds are substantially more complex than exact seeds and skip seeds
because we need to take into account all the duplicates in the
combinatorial construction.


\subsection{Hard and soft masking}

We first introduce two important notions that will be the key to
understanding the behavior of MEM seeds.

\begin{definition}
\label{def_mask}
At a given position of the read, a duplicate is a \emph{hard mask} if its
match length on the left side is strictly longer than the match length
of the target. A duplicate is a \emph{soft mask} if it has the same match
length as the target.
\end{definition}

Figure~\ref{fig:hard_vs_soft_masks} gives a graphical intuition of hard and
soft masks. It is important to bear in mind that hard and soft masks
depend on the position of interest: a sequence can be a mask at the left
end of the read and not at the right end, or the opposite.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{hard_vs_soft_masks.pdf}
\caption{\textbf{Example of hard and soft masks.}
Genomic sequences are shown below a read where open squares represent
nucleotides. In the sequences, the open squares represent matches and the
closed squares represent mismatches. The nucleotides contributing to the
match length are represented as grey boxes. At the focus position, the
match length of the target is 7. The first duplicate is a hard mask
because its match length is $13>7$. The second duplicate is a soft mask
because its match length is 7, as the target. The third duplicate is not
a mask because its match length is $2<7$.}
\label{fig:hard_vs_soft_masks}
\end{figure}

Hard and soft masks explain the counter-intuitive properties of MEM seeds.
For instance, in Figure~\ref{fig:full_masking_example} the target cannot be
discovered because every nucleotide of the read has a hard mask. In
Figure~\ref{fig:short_vs_long}, the target could be discovered if the read
were shorter because a hard mask would turn into a soft one.

From the definition, we see that the last nucleotide of every strict
on-target MEM seed is always unmasked. Conversely, an unmasked nucleotide
always belongs to exactly one strict on-target MEM (not necessarily a seed
because the size of the MEM can be less than $\gamma$). Also, the last
nucleotide of every shared on-target MEM seed is always soft-masked, but a
soft-masked nucleotide does not always belong to a shared on-target MEM.

Since hard and soft masks inform us about the positions of on-target
MEM seeds, we construct an alphabet that encodes the masking status of the
nucleotides.

\subsection{The MEM alphabet}

As before, we recode the reads as sequences of letters from a specialized
alphabet called the MEM alphabet $\mathring{\mathcal{A}} = \{\square, |,
\uparrow_{/1}, \uparrow_{/2}, \uparrow_{/3} \ldots, \downarrow_{/0},
\downarrow_{/1}, \downarrow_{/2}, \ldots\}$.

The symbols $\downarrow_{/m}$ ($m \geq 0$) indicate that the nucleotide is
a sequencing error and $m$ is the number of duplicates that \emph{match}
the nucleotide. Since a sequencing error is always a mismatch against the
target, the symbol $\downarrow_{/0}$ indicates that the nucleotide is a
mismatch against \emph{every} sequence. The symbols $\uparrow_{/i}$
indicate a change in masking status: the nucleotide is not masked but the
previous is---this happens when all the duplicates fail to extend beyond
this position. The index $i \geq 1$ is the number of nucleotides since the
last mismatch or since the beginning of the read. All the other
nucleotides are represented by the symbol $\square$, implying that
$\square$ symbols are never sequencing errors and always match the
target. The symbol $|$ is appended to the end of the read as before.

Note that in the symbols $\downarrow_{/m}$ and $\uparrow_{/i}$, the
numbers $m$ and $i$ have different meanings. In the symbol
$\downarrow_{/m}$, the index $m$ is a number of sequences ($0 \leq m \leq
N$ where $N$ is the number of duplicates); in the symbol $\uparrow_{/i}$,
the index $i$ is a number of nucleotides. Figure~\ref{fig:sketch_extended}
shows the encoding of a read in the MEM alphabet.

\begin{figure}[h]
\centering
\includegraphics[scale=.84]{sketch_extended.pdf}
\caption{\textbf{The MEM encoding}.
The read of Figure~\ref{fig:MEM_example} is represented in the MEM alphabet.
The arrows departing from the numbers help understand their meaning. The
symbol $\downarrow_{/m}$ is indexed by the number $m$ of locations that
match the nucleotide. The symbol $\uparrow_{/i}$ is indexed by the number
$i$ of nucleotides from the last error or from the beginning of the read.
The grey squares in the symbolic sequences represent MEM seed matches.
Other features are as in Figure~\ref{fig:dual}.}
\label{fig:sketch_extended}
\end{figure}

The MEM alphabet captures the masking status of the nucleotide: the symbol
$\downarrow_{/m}$ indicates that the nucleotide has $m$ hard masks and
$N-m$ soft masks. The symbols $\uparrow_{/i}$ indicate that the nucleotide
is unmasked and that the previous nucleotide is masked.

In the MEM alphabet, strict on-target MEM seeds are the longest stretches
of symbols containing some symbol $\uparrow_{/i}$ and not containing any
symbol $\downarrow_{/m}$. Indeed, such a stretch is a match for the target
because it does not contain any symbol $\downarrow_{/m}$, it only matches
the target because it contains at least one unmasked nucleotide (marked by
$\uparrow_{/i}$), and it cannot be extended because it is flanked by
sequencing errors (symbols $\downarrow_{/m}$) or by the ends of the reads.
Note that there is exactly one symbol $\uparrow_{/i}$ per strict on-target
MEM seed, and therefore two symbols $\uparrow_{/i}$ must be separated by
at least one symbol $\downarrow_{/m}$.

Shared on-target MEM seeds are the longest stretches of symbols $\square$
flanked by $\downarrow_{/0}$, or by the ends of the read. Indeed, such a
stretch is a MEM seed because it matches the target and it cannot be
extended ($\downarrow_{/0}$ is a mismatch against every sequence). Also,
it cannot be a strict on-target MEM seed because it does not contain any
$\uparrow_{/i}$ symbol, so it must be a shared on-target MEM seed.

As before, the read is converted from a sequence of symbols to a sequence
of segments that consist of 0 or more symbols $\square$ followed by a
terminator. We then specify the weighted generating functions of those
segments and fill the transfer matrix $\mathring{M}_N(z)$ of the reads that
do not contain an on-target MEM seed. We introduce the terms of the matrix
by increasing order of complexity.


\subsection{Segments following $\uparrow_{/i}$}

A segment terminated by $\uparrow_{/i}$ is the beginning of a strict
on-target MEM of size at least $i$. The MEM reaches the next sequencing
error or the end of the read, so the number of symbols $\square$ in the
next segment must be at most $\gamma-i-1$ and it must be terminated by a
$\downarrow_{/m}$ symbol or by the tail terminator $|$.

The following definition will simplify the notations.

\begin{definition}
Given the divergence rate $\mu$ and the number of duplicates $N$, the
probability that a symbol is $\downarrow_{/m}$ given that the nucleotide
is a read error is
\begin{equation}
\label{eq:omega}
\omega_m = {N \choose m} \big(1 - \mu/3\big)^{N-m} \big(\mu/3\big)^m.
\end{equation}
\end{definition}

The expression for $\omega_m$ is exact: if the nucleotide is an error,
the symbol is $\downarrow_{/m}$ for some $m$ between 0 and $N$. Each
duplicate is a match with probability $\mu/3$, so $m$ has a Binomial
distribution with parameters $(N, \mu/3)$.

On this segment, the matches between the read and the duplicates are
irrelevant, so the weighted generating function of a symbol $\square$ is
simply $qz$ (recall that $p = 1-q$ is the probability of a sequencing
error). The weighted generating function of the terminator
$\downarrow_{/m}$ is $\omega_m pz$, so the weighted generating function of
the $\downarrow_{/m}$ segments following $\uparrow_{/i}$ is
\begin{equation}
\label{eq:D}
D_{i,m}(z) = \omega_m pz \sum_{j=0}^{\gamma-i-1} (qz)^j.
\end{equation}

And the weighted generating function of the tail segments following
$\uparrow_{/i}$ is
\begin{equation}
\label{eq:E}
E_i(z) = \sum_{j=0}^{\gamma-i-1} (qz)^j.
\end{equation}


\subsection{Segments following $\downarrow_{/m}$}

The symbol $\downarrow_{/m}$ signifies that the nucleotide has $m$ hard
masks and $N-m$ soft masks. If all the masks vanish before the first read
error, the next terminator will be a symbol $\uparrow_{/j}$, otherwise it
will be the symbol $|$ or a symbol $\downarrow_{/m}$. We separate the
cases based on the terminator of the segment.

\subsubsection*{Case 1: the terminator is $\uparrow_{/j}$}

\begin{definition}
Given the divergence rate $\mu$, the probability that a given duplicate
contains a mismatch in a sequence of $j$ error-free nucleotides is
\begin{equation}
\label{eq:xi}
\xi_j = 1-(1-\mu)^j.
\end{equation}
This is the probability that a hard or soft mask vanishes within $j$
correct nucleotides.
\end{definition}

The expression for $\xi_j$ is exact: every nucleotide of the duplicate
differs from the target with probability $\mu$. In the absence of
sequencing errors, this is also the probability that a nucleotide of the
duplicate differs from the read. Given that there is no error, the
probability that $j$ nucleotides in a row are identical to the read is
thus $(1-\mu)^j$ and the probability that at least one of them is
different is the complement $1-(1-\mu)^j$.

With this notation, the probability that at least one of $N$ masks
survives a sequence of $j$ error-free nucleotides is thus $1-(\xi_j)^N$,
and the probability that there remains a mask at the $j-1$-th but not at
the $j$-th error-free nucleotide is $(\xi_j)^N - (\xi_{j-1})^N$. From this
we conclude that the weighted generating function of the segments
terminated by $\uparrow_{/j}$ following a segment terminated by
$\downarrow_{/m}$ is
\begin{equation}
\label{eq:B}
B_j(z) = \Big( (\xi_j)^N-(\xi_{j-1})^N \Big) (qz)^j.
\end{equation}

The fact that the reads have no on-target seeds imposes $j < \gamma$. Also
note that this expression is the same for all symbols $\downarrow_{/m}$
(it does not depend on $m$).

\subsubsection*{Case 2a: the terminator $|$ comes before the $\gamma$-th
nucleotide}

In this case there can be no on-target seed because the read finishes too
early. However, we must enforce the condition that at least one of the $N$
masks survives until the end, otherwise the segment would be terminated by
one of the symbols $\uparrow_{/j}$. The weighted generating function is
\begin{equation*}
\sum_{i=0}^{\gamma-1} \Big(1 - (\xi_i)^N \Big) (qz)^i.
\end{equation*}

\subsubsection*{Case 2b: the terminator $|$ comes after the $\gamma$-th
nucleotide}

In this case, the soft masks do not hide the target. Even if a duplicate
survives until the end of the read, there will be an on-target seed
(shared in this case). To exclude on-target seeds, we must enforce the
condition that at least one hard mask survives until the end of the
segment (which is impossible if $m = 0$). The weighted generating function
is
\begin{equation*}
\sum_{i=\gamma}^\infty \Big(1 - (\xi_i)^m \Big) (qz)^i.
\end{equation*}

Summing the expressions from cases 2a and 2b, we find that the
weighted generating function of the tail following $\downarrow_{/m}$ is
\begin{equation}
\label{eq:C}
C_m(z) =
\sum_{i=0}^{\gamma-1} \Big(1 - (\xi_i)^N \Big) (qz)^i +
  \sum_{i=\gamma}^\infty \Big(1 - (\xi_i)^m \Big) (qz)^i.
\end{equation}

\subsubsection*{Case 3a: the terminator $\downarrow_{/n}$ comes before the
$\gamma$-th nucleotide}

In this case, there can be no on-target seed and we must only exclude the
terminators $\uparrow_{/j}$. As we have seen above, this implies that at
least one of the $N$ masks survives until the terminator. For a read of
size $j+1$, this occurs with probability $1-(\xi_j)^N$. Including the
terminator and summing over $j+1 \leq \gamma$, we see that the weighted
generating function is
\begin{equation}
\omega_n pz \sum_{j=0}^{\gamma-1} \Big(1 - (\xi_j)^N \Big) (qz)^j.
\end{equation}

\subsubsection*{Case 3b: the terminator $\downarrow_{/n}$ comes after the
$\gamma$-th nucleotide}

This case is by far the most convoluted. Since the segment contains at
least $\gamma$ error-free nucleotides, we must enforce the condition that
it does not contain an on-target seed. This will be the case if any of the
two following conditions is validated: $i)$ at least one hard mask covers
all the error-free nucleotides, or $ii)$ all the hard masks vanish but at
least one soft mask covers the whole segment (including the terminator).

The two conditions are mutually exclusive by construction. They are
graphically represented in the diagram below. The left panel corresponds
to case $i)$ and the right panel to case $ii)$. The top row represents the
target, and the bottom rows represent duplicates (using the same symbols
as in Figure~\ref{fig:sketch_extended}).
\begin{inset}
\includegraphics{masks.pdf}
\end{inset}

Whenever a hard mask (here the first duplicate) covers the nucleotides as
shown by the grey squares in the left panel, there can be no on-target
seed. The positions marked with a question mark are irrelevant, they
cannot change the fact that there is no on-target MEM seed. If the hard
masks vanish, as in the right panel, then we need to look at the soft
masks. If a soft mask covers the whole segment as indicated by the grey
squares, then there can be no on-target seed. In all other cases there is
an on-target MEM seed.

For a segment of size $j+1$, condition $i)$ has probability $\big(1 -
(\xi_j)^m \big)$. Summing over $j+1 > \gamma$ and including the
terminator, we see that the associated weighted generating function is
\begin{equation*}
\omega_n pz \sum_{j=\gamma}^\infty \Big(1 - (\xi_j)^m \Big) (qz)^j.
\end{equation*}

Condition $ii)$ is more convoluted, so we introduce some further
notations to solve this sub-case.
\begin{definition}
Given the divergence rate $\mu$, the probability that a duplicate sequence
contains a mismatch in a sequence of $j$ error-free nucleotides followed
by an error is
\begin{equation}
\label{eq:eta}
\eta_j = 1-(1-\mu)^j\mu/3.
\end{equation}
This is the probability that a hard or soft mask vanishes within $j$
correct nucleotides followed by a sequencing error.
\end{definition}

The expression for $\eta_j$ is exact: the probability that there are $j$
matches between the duplicate and the target is $(1-\mu)^j$. If there are
no sequencing errors, this is also the probability that there are $j$
matches between the duplicate and the read. The probability that the
duplicate matches the subsequent error is $\mu/3$, so the probability
that there are $j+1$ matches including the sequencing error is
$(1-\mu)^j\mu/3$. Finally, the probability that there is a mismatch is the
complement $1-(1-\mu)^j\mu/3$.

Let us for now consider a segment of fixed size $j+1$. From expressions
(\ref{eq:xi}) and (\ref{eq:eta}), the probability of condition $ii)$ is
\begin{equation*}
(\xi_j)^m \Big(1 - (\eta_j)^{N-m} \Big),
\end{equation*}
but we need to break up this term among all the possible terminators
$\downarrow_{/n}$ ($0 \leq n \leq N$) in order to fill the different
entries of the transfer matrix. For this, we split this term in the number
of soft masks that run until and including the terminator. From expression
(\ref{eq:eta}), the probability that there are $r \geq 1$ such soft masks
is
\begin{equation}
\label{eq:softmasks_r}
{N-m \choose r} (1 - \eta_j)^r (\eta_j)^{N-m-r}.
\end{equation}

For now we consider $r$ fixed; we will compute the marginal probability at
the final stage. By construction, each of those $r$ soft masks matches the
terminator, so the total number of matches is $r$ plus the number of
sequences that also match the terminator, among the remaining $N-m-r$ soft
masks and the $m$ hard masks.

Let us start with the $m$ hard masks. The probability that each of them
matches the terminator is simply $\mu/3$.

The case of the $N-m-r$ soft masks is more complicated because they can
vanish precisely on the terminator---recall that in case $ii$) all the
hard masks are assumed to vanish before. If the soft mask failed within
the first $j$ nucleotides, then the $j+1$-th nucleotide can be anything
and it will match the terminator with probability $\mu/3$. But if the soft
mask survived the first $j$ nucleotides, then it \emph{must} fail on the
$j+1$-th and it cannot match the terminator. From expressions
(\ref{eq:xi}) and (\ref{eq:eta}), the probability that a given soft mask
fails within the first $j$ nucleotides is $\xi_j/\eta_j$---this is the
conditional probability that it fails within the first $j$ nucleotides
given that it fails within the segment. Finally the probability that such
a soft mask matches the terminator is $\mu/3 \cdot \xi_j / \eta_j$.

Summing the contributions of the hard masks ($m$ in total, each matching
the terminator with probability $\mu/3$) and of the soft masks ($N-m-r$ in
total, each matching the terminator with probability
$\mu/3\cdot\xi_j/\eta_j$), the probability that the total number of
matches is $n-r$ appears as the convolution product
\begin{eqnarray*}
\frac{(\mu/3)^{n-r}(1-\mu/3)^{N-n}}{(\eta_j)^{N-m-r}}
&\psi_{j,m,n,r}&, \\
\text{where }
&\psi_{j,m,n,r}& = \sum_{q \geq 0}{m \choose q}{N-m-r \choose n-r-q}
(\xi_j)^{n-r-q}.
\end{eqnarray*}

Finally, we need to compute the marginal probability over the number $r$
of soft masks that survive until the end of the read. Multiplying by the
probability of $r$ from expression (\ref{eq:softmasks_r}) and summing over
$r \geq 1$, the probability that $n$ duplicate sequences match the
terminator appears as
\begin{eqnarray*}
&\;& \sum_{r\geq1} {N-m \choose r}
(1 - \eta_j)^r (\mu/3)^{n-r} (1-\mu/3)^{N-n} \psi_{j,m,n,r} \\
&=& (\mu/3)^n(1-\mu/3)^{N-n} \sum_{r\geq1} {N-m \choose r}
  (1 - \mu)^{rj} \psi_{j,m,n,r} \\
&=& \omega_n \cdot \zeta_{j,m,n},
\end{eqnarray*}
where
\begin{equation}
\label{eq:zeta}
\zeta_{j,m,n} = \sum_{r\geq1} {N-m \choose r}
(1-\mu)^{rj} \psi_{j,m,n,r} \bigg/ {N \choose n}.
\end{equation}

This is the probability that the terminator is the symbol
$\downarrow_{/n}$ given that the segment has size $j+1 > \gamma$, that
the first sequencing error occurs on the last nucleotide, that the
preceding terminator was $\downarrow_{/m}$ and that the $m$ hard masks
fail before the end of the segment.

Summing the terms from case 3a and from case 3b, we find that the weighted
generating function of the $\downarrow_{/n}$ segments following
$\downarrow_{/m}$ is
\begin{equation}
\begin{split}
\label{eq:A}
A_{m,n}(z) =
&\omega_n pz \sum_{j=0}^{\gamma-1} \Big(1 - (\xi_j)^N \Big)
  (qz)^j \\
+ &\omega_n pz \sum_{j=\gamma}^\infty \Big(1 - (\xi_j)^m \cdot
(1- \zeta_{j,m,n}) \Big) (qz)^j.
\end{split}
\end{equation}

\subsection{Expression of $\mathring{M}_N(z)$}
\label{sec:expression_of_M}

Collecting and arranging the results above, we can verify that the final
expression of the transfer matrix $\mathring{M}_N(z)$ is
\begin{equation*}
\begin{blockarray}{cccccccc}
   & \dn{0} & \ldots & \dn{N} & \up{1} & \ldots & \up{\gamma-1} & \nd \\
\begin{block}{c[ccccccc]}
\dn{0} & A_{0,0}(z) & \ldots & A_{0,N}(z) & B_1(z) & \ldots &
    B_{\gamma-1}(z) & C_0(z) \\
\vdots & \vdots & \ddots & \vdots & \vdots & \ddots &
    \vdots & \vdots \\
\dn{N} & A_{N,0}(z) & \ldots & A_{N,N}(z) & B_1(z) & \ldots &
    B_{\gamma-1}(z) & C_N(z) \\
\up{1} & D_{1,0}(z) & \ldots & D_{1,N}(z) & 0 & \ldots & 0 & E_1(z) \\
\vdots & \vdots & \ddots & \vdots & \vdots & \ddots &
    \vdots & \vdots \\
\up{\gamma-1} & D_{\gamma-1,0}(z) & \ldots & D_{\gamma-1,N}(z) & 0 &
  \ldots & 0 & E_{\gamma-1}(z) \\
\nd & 0 & \ldots & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray}
\end{equation*}
where
\begin{equation}
\tag{\ref{eq:A}}
\begin{split}
A_{m,n}(z) =
&\omega_n pz \sum_{i=0}^{\gamma-1} \Big(1 - (\xi_i)^N \Big) (qz)^i \\
+ &\omega_n pz \sum_{i=\gamma}^\infty \Big(1 - (\xi_i)^m \cdot
(1- \zeta_{i,m,n}) \Big) (qz)^i 
\end{split}
\end{equation}
\begin{gather}
\tag{\ref{eq:B}}
B_i(z) = \Big( (\xi_i)^N-(\xi_{i-1})^N \Big) (qz)^i \\
\tag{\ref{eq:C}}
C_m(z) =
\sum_{i=0}^{\gamma-1} \Big(1 - (\xi_i)^N \Big) (qz)^i +
  \sum_{i=\gamma}^\infty \Big(1 - (\xi_i)^m \Big) (qz)^i \\
\tag{\ref{eq:D}}
D_{j,m}(z) = \omega_m pz \sum_{i=0}^{\gamma-j-1} (qz)^i \\
\tag{\ref{eq:E}}
E_j(z) = \sum_{i=0}^{\gamma-j-1} (qz)^i
\end{gather}
and where
\begin{gather}
\tag{\ref{eq:omega}}
\omega_m = {N \choose m} \big(1 - \mu/3\big)^{N-m} \big(\mu/3\big)^m \\
\tag{\ref{eq:xi}}
\xi_j = 1-(1-\mu)^j \\
\tag{\ref{eq:eta}}
\eta_j = 1-(1-\mu)^j\mu/3 \\
\tag{\ref{eq:zeta}}
\zeta_{j,m,n} = \sum_{r\geq1} {N-m \choose r}
(1-\mu)^{rj} \psi_{j,m,n,r} \bigg/ {N \choose n} \\
\notag
\psi_{j,m,n,r} = \sum_{q \geq 0}{m \choose q}{N-m-r \choose n-r-q}
(\xi_j)^{n-r-q}.
\end{gather}

\begin{remark}
In the special case $N=0$, the transfer matrix simplifies to the extent
that we can compute the weighted generating function of the reads without
on-target MEM seed in closed form. The result is
\begin{equation}
\tag{\ref{eq:F}}
\frac{1+qz+\ldots+(qz)^{\gamma-1}}
  {1-pz \big(1+qz+\ldots+(qz)^{\gamma-1} \big)}.
\end{equation}

Expression (\ref{eq:F}) was shown in section~\ref{sec:example_exact} to be
the weighted generating function of reads without on-target exact seed.
This shows that when there are no duplicates, MEM seeds have exactly the
same properties as exact seeds.
\end{remark}

\subsection{Computing MEM seeding probabilities}

The matrix $\mathring{M}_N(z)\cdot(I-\mathring{M}_N(z))^{-1}$ contains the
weighted generating functions of all the reads without on-target MEM
seeds. The term of interest, as usual, is the top right entry. Indeed,
every read can be prepended by $\downarrow_{/0}$ segments and only by
those, otherwise the read would start with fewer than $N$ soft masks.
Thus, reads without an on-target MEM seed are precisely the sequences of
segments that can be appended to the symbol $\downarrow_{/0}$ and that are
terminated by a tail.

To compute this term, we proceed as in section~\ref{sec:example_skip},
\textit{i.e.}, we compute the powers of $\mathring{M}_N(z)$ in the
arithmetic of truncated polynomials and we stop the iterations when the
terms are negligible. We bound the probability that the read contains more
than $e$ sequencing errors using the expression
\begin{equation*}
\tag{\ref{eq:bound}}
Pr(X \geq e) \leq \exp \left( (e-k)\log \frac{k-e}{k(1-p)} -e\log
\frac{e}{kp} \right),
\end{equation*}
but here not every segment contains an error. There cannot be two symbols
$\uparrow_{/j}$ in a row, so a read with $s+1$ segments must contain a
minimum number of sequencing errors which is $e=\lfloor{s/2\rfloor}$. As
before, we compute the powers of $\mathring{M}_N(z)$ until the upper bound
is less than a set fraction $\varepsilon$ of the current value of $a_k$.

If we call $M_0$ the event that the read contains an on-target MEM seed,
the method above gives us $P(\overline{M}_0)$. Calling $M_j$ the event
that the read contains a MEM seed for the $j$-th duplicate, we are
interested in the probability
\begin{equation*}
\tag{\ref{eq:pcomp}}
P\big(\overline{M}_0 \cap (M_1 \cup \ldots \cup M_N)\big) =
P(\overline{M}_0) - P\big(\overline{M}_0 \cap \overline{M}_1 \cap \ldots
\cap \overline{M}_N\big).
\end{equation*}

The key insight to compute $P\big(\overline{M}_0 \cap \overline{M}_1 \cap
\ldots \cap \overline{M}_N\big)$ is to realize that there is some MEM
seed, on-target or not, if and only if the read contains a match of size
$\gamma$ or more for any of the $N+1$ sequences. Therefore, this
probability is the same as the term $P\big(\overline{S}_0 \cap
\overline{S}_1 \cap \ldots \cap \overline{S}_N\big)$ computed in
section~\ref{sec:offexact}.

In conclusion, the probability that the MEM seeding process is off-target
is
\begin{equation}
\label{eq:PMEM}
P(\overline{M}_0) - P(\overline{S}_0) \cdot \left( \frac{P(\overline{S}_0
\cap \overline{S}_1)}{P(\overline{S}_0)} \right)^N,
\end{equation}
where $P(\overline{M}_0)$ is computed using $\mathring{M}_N(z)$ as
explained in this section, $P(\overline{S}_0)$ is computed using a
recursive equation as explained in section~\ref{sec:example_exact}, and
$P(\overline{S}_0\cap\overline{S}_1)$ is computed using $\tilde{M}_0(z)$
as explained in section~\ref{sec:dual}.

\subsection{Monte Carlo sampling}
\label{sec:montecarlo}

One potential difficulty in computing $P(\overline{M}_0)$ is that the
matrix $\mathring{M}_N(z)$ has dimension $(N+\gamma+1) \times
(N+\gamma+1)$. The problem can become computationally intractable because
$N$ can be very large. For instance, the sequences called \emph{Alu} have
more than one million duplicates in the human genome. There is no hope to
compute the powers of $\mathring{M}_N(z)$ in these conditions and we need
an alternative method.

The symbolic representation as MEM segments can be used to design an
efficient method to sample reads. Instead of generating the nucleotides of
the $N+1$ sequences one by one, one can generate a single sequence of
segments. Since the number of segments does not depend on $N$, we can
obtain a fast Monte Carlo method to sample millions of reads and count the
proportion that contain an on-target MEM seed.

The principle is to proceed in cycles of two steps. We first sample the
position of the next sequencing error, which gives the position of the
next symbol $\downarrow_{/m}$, where $m$ will be determined at a later
stage. The second step is to determine whether there is a symbol
$\uparrow_{/j}$ before that. For this we sample the number of masks that
vanish before the symbol $\downarrow_{/m}$. If they all vanish, the read
contains an on-target MEM seed, provided the next read error is at a
distance greater than $\gamma$. Otherwise, we sample the number $m$ of
hard masks at the sequencing error, and the process is repeated until we
generate an on-target MEM seed, or until the read has size $k$ or greater
(in which case it has no on-target MEM seed).

The method is summarized in algorithm~\ref{alg:mcmc} below. It requires
efficient algorithms to sample from the geometric and from the binomial
distributions. Sampling from a geometric distribution can be done by
computing the logarithm of a uniform $(0,1)$ random variable. Sampling
from a binomial distribution can be done by the method of
Kachitvichyanukul and Schmeiser~\cite{kachitvichyanukul1988binomial}.
Most importantly, the number of duplicates $N$ has little influence on
the running speed of algorithm~\ref{alg:mcmc}.

\begin{algorithm}[H]
\SetKwInOut{Parameter}{Parameter}
\label{alg:mcmc}
\SetAlgoLined
\Parameter {$k$ is the size of the reads.}
\Parameter {$p$ is the error rate of the sequencer (substitutions only).}
\Parameter {$N$ is the number of duplicates.}
\Parameter {$\mu$ is the nucleotide-wise probability that duplicates
differ.}
\KwResult {Sample a read at random. Return 1 if the read contains a
good MEM seed, otherwise return 0.}
  $\lambda \leftarrow 0$ \Comment*[r]{Current read size.}
  $m \leftarrow 0$ \Comment*[r]{Current number of hard masks.}
  \While {$\lambda < k$}{
    $i \leftarrow geom(p)-1$ \Comment*[r]{Error-free nucleotides.}
    \eIf {$i \geq k-\lambda$}{
      \eIf{$k-\lambda < \gamma$} {
        return 0\; }{
        $h \leftarrow binom(m,(1-\mu)^{k-\lambda})$
            \Comment*[r]{Surviving hard masks.}
        return 1 if $h = 0$, otherwise return 0\; }
    }
    {
      $h \leftarrow binom(m,(1-\mu)^i)$
          \Comment*[r]{Surviving hard masks.}
      $s \leftarrow binom(N-m,(1-\mu)^i \mu/3)$
          \Comment*[r]{Surviving soft masks.}
      \eIf {$ i \geq \gamma$ and $h = 0$ and $s = 0$}{
        return 1\;}{
        $m \leftarrow s + binom(N-s, \mu/3)$\;
        $\lambda \leftarrow \lambda + i+1$\;}
    }
 }
\end{algorithm}

Algorithm~\ref{alg:mcmc} is an important result. It gives a compact
solution to the problem of estimating the probability that a read can be
mapped when using MEM seeds. The algorithm is also much faster than the
naive approach of sampling every nucleotide of every sequence, because it
is equivalent to sampling the nucleotide sequence of \emph{all} the
duplicates.

\subsection{Illustration}
\label{sec:illmem}

We illustrate the strategy delineated above using the same settings as in
section~\ref{sec:illdual} ($k=50$, $p=0.01$ and $\gamma=19$), except that
we replace exact seed by MEM seeds.

\begin{figure}[h]
\centering
\includegraphics[scale=.48]{curves_mem.pdf}
\caption{\textbf{Off-target seeding probabilities (MEM seeds).}
The surfaces show the probability that seeding is off-target for MEM seeds
of indicated minimum size $\gamma$. Read size and error rate are the same
as in Figure~\ref{fig:curves_exact}, \textit{i.e.} $k=50$ and $p=0.01$.
The divergence rate $\mu$ is the probability that a given duplicate
differs from the target at any given position. Note the factor 1000 in the
scale of the z-axis.}
\label{fig:curves_mem}
\end{figure}

Figure~\ref{fig:curves_mem} shows the result for a number of duplicates
$N$ from 1 to 10, for a divergence rate $\mu$ from 0 to 0.20 and for MEM
seeds of different minimum size $\gamma$. The surfaces have the same
general aspect as those of Figure~\ref{fig:curves_exact}. The probability
that seeding is off-target increases with $N$, as shown by expression
(\ref{eq:PMEM}).

There is again a  worst value of $\mu$ in each plot, but it is much lower
than the previous two cases (it is close to 0.028 for $\gamma=14$i and
$\gamma=19$, 0.030 for $gamma=27$ and .035 for $\gamma=34$). In the case
of MEM seeds, it is not obvious why the same value of $\mu$ maximizes
(\ref{eq:PMEM}) for all values of $N$ because both $P(\overline{M}_0)$ and
$P(\overline{S}_0 \cap \overline{S}_1)$ depend on $\mu$.

Figure~\ref{fig:curves_mem} reveals that in this concrete case, MEM seeds
increase the chances that seeding is off-target by a factor 15
compared to exact seeds (see Figure~\ref{fig:curves_exact}). On this
criterion, MEM seeds are always inferior to exact seeds with the same
specifications. The reason is that a MEM seed always contains at least one
exact seed of size $\gamma$. MEM seeds tremendously simplify the seeding
process, but this comes at the cost of an increase of the probability that
seeding is off-target.

Also note that the values change less than one might expect when varying
the minimum seed length $\gamma$. Part of the reason is that MEM seeds are
typically longer than their minimum size $\gamma$. In any event, this
example shows that reducing $\gamma$ to gain sensitivity provides very
modest benefits, with potentially high costs in terms of short spurious
hits.


\section{The Sesame library}
\label{sec:sesame}

We implemented the methods and algorithms presented here in an open-source
C library to compute seeding probabilities. The library is called Sesame
and is available at \url{https://github.com/gui11aume/sesame}.

\subsection{Main features of Sesame}

Sesame contains functions to compute the seeding probabilities described
here. All the functions were tested against simulations to ensure that the
implementation is accurate and the code was checked extensively by static
analysis and unit testing.

Computing seeding probabilities can take up to a few seconds, even when
replacing iterative methods by Monte Carlo simulations. This is
incompatible with the speed requirements of modern mappers, so Sesame has
an interface for this type of application. In this mode, Sesame computes
the results only the first time and stores them in memory for reuse on
subsequent calls.

Storing the results in memory is an efficient strategy because three
parameters are constant throughout the sequencing run: the minimum seed
size $\gamma$, the read size $k$ and the error rate of the sequencer $p$
(and for skip seeds, the number of skipped nucleotides $n$ is also
constant). Only two parameters depend on the read: the number of
duplicates $N$ and their divergence rate $\mu$. In this mode, Sesame
automatically switches to Monte Carlo sampling when $N$ is large to save
time. Also, the input parameters are ``snapped'' to a predefined grid of
set values for $N$ and $\mu$, so that few computations are performed and
most of the calls are actually memory lookups. Sesame can thus be
integrated in short read mappers without being a bottleneck.

Alternatively, the probabilities of interest can be computed offline,
saved to disk and loaded at run time. This is particularly useful if the
sequencing runs follow some standard conditions with a known error rate,
because the computations can be recycled between runs.

Finally, Sesame also has an offline interface, where seeding probabilities
are computed exactly as requested by the users, \textit{i.e.} without
modifying the algorithm or the parameters, and also without storing the
results in memory.

The Sesame manual, available from the repository, contains additional
information and explains in detail how to use the library.


\subsection{Using Sesame to compare seeding strategies}

As a tool to compute seeding probabilities, Sesame can be used to compare
the merits of different strategies. The kind of insight that we can gain
from such calculations was already showcased in
Figure~\ref{fig:curves_exact}, Figure~\ref{fig:curves_skip} and
Figure~\ref{fig:curves_mem}, where the numbers were computed using Sesame.

To further showcase the potential benefits of computing seeding
probabilities, we use Sesame to compare the default seeding strategies of
BWA-MEM~\cite{li2013aligning} and Bowtie2~\cite{pmid22388286}. Note that
both mappers use advanced techniques to refine the seeds, so this
comparison does not reflect the true performance of the mappers. It is
nevertheless useful to know the baseline of each strategy. The default of
BWA-MEM is to use MEM seeds of minimum size 19; that of Bowtie2 is to use
skip-9 seeds of size 16.

\begin{figure*}[t]
\begin{center}
\includegraphics[scale=.41]{mortal_kombat.pdf}
\end{center}
\caption{\textbf{Comparing seeding strategies with Sesame.} Left: MEM
seeds with $\gamma=19$ and $\mu=0.06$. Right: skip-9 seeds with
$\gamma=16$ and $\mu=0.06$. The probabilities that seeding is off-target
were computed using Sesame. Each curve represents the probability for a
given number of duplicates ($N$). Estimates using iterative methods (skip
seeds and MEM seeds where $N \leq 20$) were computed to within 1\%
accuracy. Estimates using Monte Carlo sampling (MEM seeds where $N > 20$)
were computed as the average of 500 million simulations.
}
\label{fig_mortal_kombat}
\end{figure*}

The probabilities that seeding is off-target for different read sizes $k$
and different number of duplicates $N$ are plotted in
Figure~\ref{fig_mortal_kombat}. The left panel shows the results for MEM
seeds and the right panel shows the results for skip seeds. Here the error
rate $p$ is set to 1\%, close to the specifications of the Illumina
platform~\cite{pmid21576222}, and the divergence rate between duplicates
$\mu$ is set to an arbitrary value of 6\%.

The behaviors of the two types of seeds are dramatically different. Let us
start with MEM seeds. For every value of $N$, the probability initially
increases with the read size, and then drops exponentially. The initial
increase is a hallmark of MEM seeds; it is due to the fact that duplicates
can mask the target. Note that the asymptotic decay depends on the number
of duplicates $N$ because each duplicate can mask the target and thereby
reduces the probability that it is discovered. Overall, these results show
that the performance of MEM seeds is poor when the target has more than
approximately 20 duplicates.

Turning to skip seeds, we see that the curves have a staircase look with a
drop every 10 nucleotides. This is so because seeding probabilities remain
unchanged until there is space for another seed of size 16 on the read.
The curves are otherwise decreasing with a steady exponential trend where
the asymptotic decay does not depend on the number of duplicates $N$. The
reason is that duplicates do not prevent the target from being discovered,
they merely fool the mapper when the target was not found. This property
makes the asymptotic decay of skip seeds substantially faster that of MEM
seeds when $N$ is large.

Those properties are self-evident in retrospect, but they are not
necessarily obvious from the definitions of MEM seeds and skip seeds.
The main limitations of the MEM seeds are best understood by keeping in
mind that their asymptotic decay depends on $N$.

Figure~\ref{fig_mortal_kombat} suggests that skip-9 seeds of size 16 are
just better than MEM seeds of size 19. However, the gain in sensitivity
comes at the cost of a larger candidate set, slowing down the mapping
process. To remain competitive, Bowtie2 further filters the candidate set
using a priority policy. But since some candidates are not checked, the
probability that seeding is off-target is larger than shown in
Figure~\ref{fig_mortal_kombat}. Also, we will show in
section~\ref{sec:truevsbest} that the higher sensitivity of skip seeds is
not as big an advantage as it looks because seeding is not the only source
of mapping errors.

\subsection{Key insights about MEM seeds}

At least two key insights about MEM seeds can be gained from
Figure~\ref{fig_mortal_kombat}. The first is that it is not worth it for a
MEM-based mapper to check all the candidate loci when there are more than
approximately 20 of them. The mapper may find the correct location, but
even if this is the case, the mapping quality will remain low because the
prior chances of failure were high. A better strategy is to either bail
out to not waste time, or to switch to a more sensitive seeding method
(BWA opts for the second and uses a re-seeding policy). It is also
important to note that this decision should be based on an estimated value
of $N$ and not, for instance, on the size of the seed or some other
variable.

A second insight is that for MEM seeds, the off-target rate is always
above $10^{-3}$ for reads of 50 nucleotides or fewer. Here it is important
to mention that the value $\mu=0.06$ is not even the worst for reads of
this size when $p=0.01$ (according to Figure~\ref{fig:curves_mem}, the
worst value is around 0.02-0.03). So if $\mu$ is unknown and one wishes to
be conservative, it seems that reads of 50 nucleotides cannot be mapped
with confidence better than $1/1000$.

However, this is not true for the reason that it is practically impossible
to map an Illumina read of size 50 to the wrong location when $N=0$ (see
section~\ref{sec:random_seeds}). Indeed, incorrect locations are unrelated
sequences in this case, and it is easy to recognize that two sequences of
size 50 are not homologous. This means that the highest impact one can
have on the mapping quality is to check whether $N$ is 0, or in other
words, whether the target is a unique sequence.

These insights suggest that there is a way to make MEM seeds more useful
for short read mappers. Following these principles, we have implemented a
prototype mapper based on Sesame that shows good overall
performance~\cite{zorita2020mapping}.


\section{Practical considerations}
\label{sec_practical}

\subsection{True versus best location}
\label{sec:truevsbest}

Early in the development of the theory, we distinguished the true location
from the best location. We swiftly assumed that they are identical in
order to eliminate some practical considerations that would otherwise
clutter the exposition. Throughout the article we have developed a
framework to compute the probability that the \emph{true} location is in
the candidate set. We have not mentioned anything about the probability
that the \emph{best} location is in the candidate set, so our results do
not address the best location problem. It remains to establish how they
contribute to addressing the \emph{true} location problem.

The issue at hand is that the candidates are tested with an alignment
algorithm that returns the best location. So even if the true location is
in the candidate set, the read may be mapped somewhere else because some
other candidate has a better alignment score. The question is how often
this happens. If this is a rare event, our results give a good
approximation of the probability that a read is mapped to the true
location. Otherwise the estimates may not be so useful in practice.

The answer depends on the seed type. We start with MEM seeds because they
will allow us to highlight an important phenomenon. The key insight is
that MEM seeds tend to exclude the target from the candidate set if it is
not the best location. To develop an intuition as to why this is the case,
consider a read with a single sequencing error. The only way a candidate
can have a better score is to be a perfect match for the read. But in this
case the true location is hard-masked (see definition~\ref{def_mask}) and
it is not in the candidate set.

\begin{table}
% MEM seeds.
\renewcommand{\arraystretch}{1.1}
\centering
\begin{tabular}{ccccc}
k & N & Not seeded & Seeded, not best & Relative error \\
\hline
50  &  1  & $9.2 \cdot 10^{-4}$ & $8.4 \cdot 10^{-5}$ & $1.09$ \\
50  & 10  & $9.0 \cdot 10^{-3}$ & $7.9 \cdot 10^{-4}$ & $1.09$ \\
50  & 100 & $8.1 \cdot 10^{-2}$ & $5.1 \cdot 10^{-3}$ & $1.06$ \\
100 &  1  & $2.4 \cdot 10^{-5}$ & $7.3 \cdot 10^{-6}$ & $1.30$ \\
100 & 10  & $2.9 \cdot 10^{-4}$ & $6.9 \cdot 10^{-5}$ & $1.24$ \\
100 & 100 & $5.5 \cdot 10^{-3}$ & $5.7 \cdot 10^{-4}$ & $1.10$
\end{tabular}
\caption{Simulations of mapping errors with MEM seeds. Ideal reads were
randomly generated 1,000,000 times with sequencing error rate $p = 0.01$,
divergence rate $\mu = 0.06$, varying the read size $k$ and number $N$ of
duplicates as indicated, using MEM seeds of minimum size $\gamma = 19$.
\textit{Not seeded} shows how often the read had no seed for the target,
\textit{Seeded, not best} shows how often the read had a seed for the
target but the target was not the best candidate, and \textit{Relative
error} shows the factor between the probability that the read is not
mapped to the true location and the probability that seeding is
off-target.}
\label{table_mem}
\end{table}

Excluding ties, there are two possibilities: either the true location is
the best, in which case it is seeded and the read is correctly mapped; or
the true location is not the best, in which case it is not seeded and the
read is mapped incorrectly. The read is mapped to the true location if and
only if seeding is on target. In practice there are ties, and reads can
have more than one error, but this is a general trend for MEM seeds.

Table~\ref{table_mem} shows the results of simulations with MEM seeds
where we dissociate the true from the best location. In each tested
condition, we record how often the reads are mapped incorrectly because
seeding was off-target. Importantly, we also record the cases where reads
are mapped incorrectly despite the fact that seeding was on target. The
results show that the second case occurs a minor fraction of the time,
meaning that the probability that seeding is on target is close to the
probability that the read is mapped to the true location.

For exact and skip seeds, the conclusions are different. The situation is
even the opposite if we consider reads with a single sequencing error. In
this case the target is always in the candidate set (if the read size is
greater than $2\gamma$, where $\gamma$ is the minimum seed length), so
mapping errors are never due to failures of the seeding heuristic.
Instead, mapping errors happen only when the true location is not the
best.

\begin{table}
% Skip-9 seeds.
\renewcommand{\arraystretch}{1.1}
\centering
\begin{tabular}{ccccc}
k & N & Not seeded & Seeded, not best & Relative error \\
\hline
50  &  1  & $1.7 \cdot 10^{-4}$ & $4.9 \cdot 10^{-4}$ & $3.9$ \\
50  & 10  & $1.6 \cdot 10^{-3}$ & $4.7 \cdot 10^{-3}$ & $3.9$ \\
50  & 100 & $7.9 \cdot 10^{-3}$ & $4.4 \cdot 10^{-2}$ & $6.6$ \\
100 &  1  & $4.4 \cdot 10^{-8}$ & $2.3 \cdot 10^{-5}$ & $523.7$ \\
100 & 10  & $3.5 \cdot 10^{-7}$ & $2.3 \cdot 10^{-4}$ & $658.1$ \\
100 & 100 & $1.0 \cdot 10^{-6}$ & $2.3 \cdot 10^{-3}$ & $2301.0$
\end{tabular}
\caption{Simulations of mapping errors with MEM seeds. Ideal reads were
randomly generated 1,000,000 times with sequencing error rate $p = 0.01$,
divergence rate $\mu = 0.06$, varying the read size $k$ and number $N$ of
duplicates as indicated, using skip-9 seeds of size $\gamma = 19$. The
meanings of the columns are the same as in Table~\ref{table_mem}.}
\label{table_skip}
\end{table}

Table~\ref{table_skip} shows the results of similar simulations with
skip-9 seeds. In all the tested cases the probability that the true
location is not the best is substantially higher than the probability that
seeding is off-target. As a result, the Sesame estimates are very far from
the probability that the read is not mapped to the true location.
The results for exact seeds are omitted, but they are qualitatively
similar to those obtained for skip-9 seeds.

In conclusion, the off-target probabilities computed by Sesame are close
to the probability that the read is not mapped to the true location when
using MEM seeds. In contrast, the estimates are very far when using exact
seeds and skip seeds. In this case, it is more accurate to use an estimate
of the probability that the true location is not the best, which is
relatively easy to compute given the error rate of the sequencer $p$, the
number of duplicates $N$ and their divergence rate $\mu$.


\subsection{Realistic sequencing errors}

In order to make the model tractable, we had to make some simplifying
assumptions regarding the distribution of errors
(section~\ref{sec:error}). In particular, we assumed that sequencing
errors are uniform on the read, which is known to not be the case with
current instruments. The errors are typically more frequent at the ends of
the reads~\cite{pmid21576222}, meaning that seeds may be longer than
expected, impacting the probability that seeding is off-target.

To test whether this is the case, we used the ART
simulator~\cite{pmid22199392} to emulate the error distribution of
Illumina reads as per technology standards of 2016. We used the settings
for the Illumina HiSeq 2000 and generated random reads of size 50 and 100
from the human genome. We estimated the probability that seeding is
off-target from simulations and compared the results to calculations
performed by Sesame (ART suggests error rates $p=0.0052$ and $p=0.0075$
for reads of size 50 and 100, respectively).

Table~\ref{table_MEM_Illumina} shows the results for MEM seeds of minimum
size $\gamma=19$. The discrepancy with Sesame estimates is always within a
factor 1.2. Table~\ref{table_skip_Illumina} shows the same type of
comparison for skip-9 seeds of size $\gamma=19$. The values are
substantially lower than for MEM seeds because skip-9 seeds are more
sensitive. In these conditions, the discrepancy with the Sesame estimates
is within a factor 1.5, but it is important to highlight that simulations
are unreliable for events with very low probability.

\begin{table}
% MEM seeds.
\renewcommand{\arraystretch}{1.1}
\centering
\begin{tabular}{ccccc}
k & N & Sesame & Simulation & Ratio \\
\hline
50  &  1  & $4.5 \cdot 10^{-4}$ & $3.8 \cdot 10^{-4}$ & 1.18 \\
50  & 10  & $4.5 \cdot 10^{-3}$ & $4.4 \cdot 10^{-3}$ & 1.02 \\
50  & 100 & $4.0 \cdot 10^{-2}$ & $4.2 \cdot 10^{-2}$ & 0.95 \\
100 &  1  & $3.7 \cdot 10^{-5}$ & $3.5 \cdot 10^{-5}$ & 1.05 \\
100 & 10  & $4.2 \cdot 10^{-4}$ & $4.1 \cdot 10^{-4}$ & 1.02 \\
100 & 100 & $8.9 \cdot 10^{-3}$ & $8.6 \cdot 10^{-3}$ & 1.03
\end{tabular}
\caption{Simulations of seeding errors with MEM seeds. Realistic Illumina
HiSeq 2000 reads were randomly generated 1,000,000 times varying the read
size $k$ and number $N$ of duplicates as indicated, and fixing the
divergence rate to $\mu = 0.06$ and using MEM seeds of minimum size
$\gamma=19$. \textit{Sesame} shows the probability that seeding is
off-target as computed with Sesame, \textit{Simulation} shows this
probability estimated by the simulation, and \textit{Ratio} shows their
ratio.}
\label{table_MEM_Illumina}
\end{table}

\begin{table}
% Skip seeds.
\renewcommand{\arraystretch}{1.1}
\centering
\begin{tabular}{ccccc}
k & N & Sesame & Simulation & Ratio \\
\hline
50  &  1  & $4.5 \cdot 10^{-5}$ & $4.5 \cdot 10^{-5}$ & 1.00 \\
50  & 10  & $4.2 \cdot 10^{-4}$ & $3.9 \cdot 10^{-4}$ & 1.07 \\
50  & 100 & $2.1 \cdot 10^{-3}$ & $1.9 \cdot 10^{-3}$ & 1.11 \\
100 &  1  & $< 10^{-6}$         & $< 10^{-6}$         & NA   \\
100 & 10  & $3 \cdot 10^{-6}$   & $2 \cdot 10^{-5}$   & 1.50 \\
100 & 100 & $8 \cdot 10^{-6}$   & $6 \cdot 10^{-4}$   & 1.33
\end{tabular}
\caption{Simulations of seeding errors with skip-9 seeds. Realistic Illumina
HiSeq 2000 reads were randomly generated 1,000,000 times varying the read
size $k$ and number $N$ of duplicates as indicated, and fixing the
divergence rate to $\mu = 0.06$ and using MEM seeds of minimum size
$\gamma=19$. The meanings of the columns are the same as in
Table~\ref{table_MEM_Illumina}.}
\label{table_skip_Illumina}
\end{table}

Overall, these results suggest that the relatively strong assumptions
regarding the distribution of errors are not a major issue in practice.
The answer of course depends on the type of sequencer that is used and on
the particulars of the mapping problem.

In practical applications, it is likely that other factors will be more
detrimental for the precision of the estimates. For instance, the number
of duplicates $N$ and their divergence rate $\mu$ are unknown, introducing
an uncertainty that propagates to the Sesame estimates. Importantly, we
assumed that duplicates evolve independently of each other and with
uniform substitutions even in the simulations featured in
Table~\ref{table_MEM_Illumina} and \ref{table_skip_Illumina} because more
realistic models are tedious to implement. The burden of this assumption
on the precision of the estimate in practical settings is difficult to
gauge. Overall, Sesame estimates should be considered approximate in all
applications with real biological data.


\subsection{Spurious random hits}
\label{sec:random_seeds}

We have assumed that seeds can match only the target or one of its
duplicates. In reality, seeds have a small chance to match any sequence of
the genome.

We have assumed throughout that all the genomic sequences that have a
perfect match for a seed are considered candidate locations. The hope is
that spurious random matches are shorter than the minimum seed length
$\gamma$, but this is not always the case. And as mentioned above, every
candidate location must be verified by an exact alignment algorithm.

Such random hits can be problematic for two reasons: First, the time spent
verifying them is wasted. Second, they can cause false positives.
Fortunately, both issues can be addressed.

To save time during the alignment phase, we can prioritize the seeds so
that the best location is likely to be discovered first, allowing us to
bail out from other alignments as early as possible. In some cases, it is
even possible to give an upper bound on the alignment score of a candidate
location so that the alignment can be skipped altogether. These
considerations depend on the implementation of the mapper so we will not
develop this further. What matters is that random hits do not impose a
significant burden on the time needed to verify the candidates.

The second issue is that random hits can generate false positives. Such
cases occur when seeding is null (meaning that there is no seed for either
the target or any of its duplicates). Even when seeding is null, the
candidate set is in general not empty because of spurious random hits. But
since such hits are not homologous to the read, the alignment score is
noticeably low, and this case is easy to detect.

Indeed, if the candidate location is random, mismatches occur with
probability 3/4. If it is the true location, mismatches occur with
probability $p$. We discard the seed because it is an automatic match of
size $\gamma$ (and possibly larger in the case of MEM seeds). Say that
there remain $L$ nucleotides and that $m$ of them are mismatches for the
candidate location. From Bayes formula, the probability that the location
is random given the number of mismatches is
\begin{equation}
\label{eq:bayes}
\frac{1}{1 + 4^L(p/3)^mq^{L-m}(1-\beta)/\beta},
\end{equation}
where $q=1-p$ and $\beta$ is the prior probability that the hit is
a spurious.

The value of $\beta$ has little importance if $p$ is small. To give an
example, say that $p=0.01$ and that a read generates a hit in the genome
such that 33 nucleotides need to be aligned after seeding. If the hit is
random there is a 99.99\% chance that at least 15 are mismatches. For
$m=15$, the denominator of expression (\ref{eq:bayes}) is approximately $1
+ 4.3\cdot10^{-18}(1-\beta)/\beta$. So unless $\beta < 10^{-17}$, the
support for the hypothesis that the hit is random is overwhelming.
Conversely, if the hit is not random, there is a 99.99\% chance that 4 or
fewer nucleotides are mismatches. For $m=4$, the denominator is
approximately $1+6.8\cdot10^9(1-\beta)/\beta$, so unless $1-\beta <
10^{-9}$, the support for the hypothesis that the hit is not random is
overwhelming. In summary, if $p$ is small, we do not need to worry about
the value of $\beta$, one can choose for instance $\beta=1/2$ so that the
term $(1-\beta)/\beta$ disappears from expression (\ref{eq:bayes}).

Since the probability that the best candidate is a random sequence is
either very small or very large, it has no influence in the first case,
and it dominates the probability of a false positive in the second case.
Checking the value of expression (\ref{eq:bayes}) after mapping reveals
whether the hit should be discarded and the read should be considered
unmapped.

In summary, spurious random hits occur regularly, but it is possible to
minimize their computational burden. Also, they are no cause for concern
regarding false positives because they can easily be detected using Bayes'
formula, as shown in expression (\ref{eq:bayes}).


\section{Discussion}
\label{sec_disc}

We have devised a set of methods to compute the probability that seeding
heuristics fail and commit the mapping process to an error. We have also
implemented the algorithms as an open source C library to perform the
computations. This fills a knowledge gap to understand and calibrate the
performance of the seeding heuristics. The pillars of our strategy are
borrowed from analytic combinatorics~\cite{flajolet2009analytic,
sedgewick2013introduction, regnier2000unified, nicodeme2002motif}, even
though we do not follow the complete programme. Constructing generating
functions usually serves the purpose of finding their singularities in
order to approximate the solution. In our case, however, the weighted
generating functions cannot be computed so this strategy is not
applicable.

To find the probabilities of interest in the absence of a fully specified
weighted generating function, we compute only the first terms of the
Taylor series using iterative methods as explained in
section~\ref{sec:example_skip}, or using Monte Carlo sampling as explained
in section~\ref{sec:montecarlo}. In this regard, the breakthrough is the
encoding of reads as segments in different alphabets, which is an implicit
form of Markov imbedding~\cite{fu1994distribution}.

Our strategy relies on the knowledge of two essential parameters: the
number of duplicates $N$ and their divergence rate $\mu$. These quantities
can be estimated efficiently using the
FM-index~\cite{ferragina2005indexing} as shown in our related work on a
prototype mapper based on the concepts developed in this
article~\cite{zorita2020mapping}.

The method presented here is general, but it is important to clearly state
the assumptions it depends on. First and most importantly, we have ignored
insertions and deletions. We assume that the sequencing errors are
substitutions only, which makes the method adapted to the Illumina
technology, but not to deletion-prone instruments such as the Oxford
Nanopore technology. We also assume that insertions and deletions never
occur among duplicated sequences. This is obviously incorrect, but our
initial tests with real data suggest that this is a minor impediment.
Incorporating insertions and deletions would make the theory intractable,
so it is presently unclear how to deal with this type of error.

The second assumption is that the candidate set consists of all the
genomic locations that have a perfect match for at least one seed, and
that all the elements of the candidate set are tested with an exact
sequence alignment algorithm. This is possible, but it is important to
note that for plant and animal genomes, a single seed may have tens of
thousands of hits. Therefore, most mappers impose a limit on the number of
alignments per read, opening the possibility that the best hit is seeded
but not aligned. It is clear that in this case, the probability that the
target is in the candidate set has little to do with the probability that
the read is mapped correctly. This is again a minor impediment, since the
probability of mapping such reads correctly is low either way. Mappers can
have a lower range of confidence score when the candidate set is too
large to check every sequence.

The third assumption is that all the duplicate sequences evolve
independently of each other and at the same rate. This is again incorrect
because duplication events can happen continuously, creating complex
ancestry relationships. It is possible to infer the ancestry using tree
reconstruction techniques, but it would be challenging to incorporate this
information in the present theory. The symbols of the alphabets developed
above implicitly assume that the sequences are exchangeable and the
complexity of the calculations explodes if it is not the case.

The last assumption is that seeds can match only the target or its
duplicates. This does not hold in general because the candidate set
usually contains spurious random hits, but we have shown how to deal with
this possibility \textit{a posteriori} in section~\ref{sec:random_seeds}.

We have not treated the case of spaced seeds. It is possible to find a
transfer matrix for reads that contain no match for a given spaced seed,
but as the number of don't-care positions increases, the dimensions of the
matrix become prohibitively large. This is a well known difficulty. The
analytic combinatorics approach presented here is equivalent to defining
finite automata that recognize seed-containing reads. Automata can be used
to compute the sensitivity of spaced seeds~\cite{kucherov2005multiseed,
buhler2005designing}, with the caveat that such automata can contain a
very large amount of states (equivalent to the rows of the transfer
matrix). To our knowledge, the transfer matrix method does not provide any
significant advantage over existing alternatives for spaced seeds.

Being able to compute seeding probabilities revealed some interesting
facts (sections~\ref{sec:illdual}, \ref{sec:illskipdual} and
\ref{sec:illmem}). The first is that the seeding schemes considered here
have a worst case scenario for a particular value of $\mu$, the divergence
between duplicates. Importantly, the worst value varies between different
seeding methods, so it is possible in theory to construct opportunistic
seeding strategies that pick the best method for every read, depending on
the value of $\mu$. Another interesting fact is that skip seeds can have
better performance than exact seeds in the sense that they can yield lower
off-seeding probabilities (section~\ref{sec:illskipdual}). However, this
always comes at the cost of accuracy because skipping nucleotides reduces
the probability of on-target seeding.

We also observed that MEM seeds have a significantly higher off-target
seeding rate compared to exact seeds and skip seeds
(section~\ref{sec:illmem}). This does not mean that MEM seeding is a bad
strategy (it is usually faster than the other methods), but it is good
practice to keep an eye on performance and switch methods or even skip the
read altogether if the chances of discovering the target are too low. We
also showed in section~\ref{sec:truevsbest} that for MEM seeds, the
on-target seeding rate is close to the probability that the read is mapped
to the true location, which was not the case for exact seeds and skip
seeds. In this regard, the present theory is most useful when using MEM
seeds.

Regarding the methodology, the Monte Carlo approach of
algorithm~\ref{alg:mcmc} is relatively straightforward, so one may wonder
why the approach with weighted generating functions would be necessary at
all for MEM seeds. The only reason is precision. To estimate the frequency
of an event by Monte Carlo sampling, this event must occur at least a few
times in the simulation. For instance, with 1 million rounds of sampling,
frequencies around $1/100,000$ or lower cannot be measured accurately.
When one is interested only in frequent events, it is thus a reasonable
strategy. On the other hand, for $N < 20$, the probability that MEM
seeding is null or off-target is relatively small, so we need a method
that is accurate in this range. Fortunately, the transfer matrix method is
fast because the dimension of the matrix $\mathring{M}_N(z)$ is small and
the computations are not prohibitive for small values of $N$.

The proposed methods meet the demand for speed. One needs to compute the
probabilities only once for a given value of $N$ and $\mu$ (the error rate
$p$ is known and constant). For $N > 20$, the iterative method is usually
too slow and we need to use Monte Carlo sampling instead. The running time
depends on $p$, on the size of the reads $k$, and on the desired number of
iterations. Since those are constant throughout the sequencing run, the
method always takes the same amount of time (around 1-10 seconds for
1,000,000 simulations of reads of size around $100$ nucleotides on modern
hardware). The values of $N$ and $\mu$ can be binned in intervals so that
there are only around $100$ pairs for a total cost of a few minutes per
run. Considering that mappers seem to process at most $10,000$ reads per
second per core, the time of mapping a sequencing run of 250 million reads
is over 7 hours per core, two orders of magnitude larger than the time
required to estimate the probabilities of error.

Finally, one may wonder if our approach has any advantage over methods
based on machine learning. Such algorithms have already proved
useful~\cite{lee2014mosaik} and the rapid progress in the field of deep
learning suggests that it is possible to train algorithms to accurately
estimate mapping quality. In time, such algorithms may prove faster and/or
more robust because they could learn intrinsic biases of the mapping
algorithms. Yet, the main benefit of our approach will remain: the
combinatorial constructions are a direct access to the nature of the
problem. For instance, viewing MEM seeds through the lens of hard and soft
masks turns a seemingly intractable process into a relatively simple one
(see algorithm~\ref{alg:mcmc}). The combinatorial stance is that there is
value in the models themselves.

In conclusion, we presented a practical solution to the problem of
estimating the probability of false positives when using seeding
heuristics. This solution is adapted for mapping short reads sequenced
with the Illumina technology. Being able to calibrate the seeding
heuristic not only allows the user to choose how to balance speed versus
accuracy, but also opens new applications. For instance, one can map reads
from contaminated samples in pools of closely related genomes
(\textit{e.g.}, modern human and Neanderthal) in order to assign the reads
to the organism they belong to. In this case, the probabilities of false
positives give the right level of confidence in the assignment.

More generally, the analytic combinatorics programme is a very powerful
tool to address problems in bioinformatics. Here we have seen how this
strategy can be useful even when the generating functions cannot be
computed. Using the same ideas, one could calibrate heuristics used in
other alignment methods, especially in the expanding field of long-read
technologies.


\section*{Acknowledgements}

We acknowledge the financial support of the Spanish Ministry of Economy,
Industry and Competitiveness (`Centro de Excelencia Severo Ochoa
2013-2017', Plan Estatal PGC2018-099807-B-I00), of the CERCA
Programme~/~Generalitat de Catalunya, and of the European Research Council
(Synergy Grant 609989). R.~C. was supported by the People Programme
(Marie Curie Actions) of the European Union's Seventh Framework Programme
(FP7/2007-2013) under REA grant agreement 608959. We also acknowledge
support of the Spanish Ministry of Economy and Competitiveness (MEIC) to
the EMBL partnership.

%---------------------------------------------------------------
%---------------------------------------------------------------

\bibliography{references,pubmed}
\bibliographystyle{unsrt}

%----------------------------------------------------------------

\appendix

\section{Definitions}
\label{app_def}
\setcounter{definition}{0}

For convenience we reproduce here the definitions introduced in the text.

\begin{definition}
The target is the DNA fragment that was actually sequenced. Duplicates are
sequences of the genome that share homology with the target (in genetics
they are often referred to as paralogs). In this article we will focus on
short reads from complex eukaryotic genomes, so for concreteness the
reader can assume that fragments are 30-300 bp long and that duplicates
have above 75\% identity with the target.
\end{definition}

\begin{definition}
The output of the seeding step is the candidate set. The candidate set is
the list of genomic locations where the read can be potentially mapped.
The read is always mapped to one element of the candidate set. The seeding
step is said to be
\begin{enumerate}[i)]
\item ``on target'' if the candidate set contains the target,
\item ``off-target'' if the candidate set contains a duplicate but not the target, 
\item ``null'' if the candidate set contains neither.
\end{enumerate}
In this article, we will always consider that a genomic location is in the
candidate set if and only if the read contains at least one seed with a
perfect match for this genomic location.
\end{definition}

\begin{definition}
A seed is a subsequence of the read that has size at least $\gamma$
(defined by the context of the problem) and that has at least one perfect
match in the reference genome. Every genomic match of every seed is in the
candidate set. 
\end{definition}

\begin{definition}
A Maximal Exact Match (MEM) is a subsequence of the read that is present
in the reference genome and that cannot be extended---either because the
read ends or because the extended subsequence is not in the genome.
\end{definition}

\begin{definition}
A \emph{strict} MEM seed has a single match in the genome.
A \emph{shared} MEM seed has several matches in the genome.
\end{definition}

\begin{definition}
Let $\mathcal{A}$ be a set of combinatorial objects such that $a \in
\mathcal{A}$ has a size $|a| \in \mathbb{N}$ and a weight $w(a) \in
\mathbb{R}^+$. The weighted generating function of $\mathcal{A}$ is
defined as

\begin{equation}
\tag{\ref{eq:GF1}}
A(z) = \sum_{a \in \mathcal{A}} w(a) z^{|a|},
\end{equation}
Expression (\ref{eq:GF1}) also defines a sequence $(a_k)_{k \geq 0}$ such
that 

\begin{equation*}
A(z) = \sum_{k=0}^\infty a_k z^k.
\end{equation*}

By definition $a_k = \sum_{a \in A_k}w(a)$, where $A_k$ is the class of
objects of size $k$ in $\mathcal{A}$. The number $a_k$ is the
total weight of objects of size $k$.
\end{definition}

\begin{definition}
\label{def:seg}
A terminator is any symbol that is different from the symbol $\square$. A
segment is a sequence of 0 or more $\square$ symbols followed by a
terminator. The tail is the last segment of the read, where the terminator
is always the special symbol $|$.
\end{definition}

\begin{definition}
At a given position of the read, a duplicate is a \emph{hard mask} if its
match length on the left side is strictly longer than the match length
of the target. A duplicate is a \emph{soft mask} if it has the same match
length as the target.
\end{definition}

\begin{definition}
Given the divergence rate $\mu$ and the number of duplicates $N$, the
probability that a symbol is $\downarrow_{/m}$ given that the nucleotide
is a read error is
\begin{equation}
\tag{\ref{eq:omega}}
\omega_m = {N \choose m} \big(1 - \mu/3\big)^{N-m} \big(\mu/3\big)^m.
\end{equation}
\end{definition}

\begin{definition}
Given the divergence rate $\mu$, the probability that a given duplicate
contains a mismatch in a sequence of $j$ error-free nucleotides is
\begin{equation}
\tag{\ref{eq:xi}}
\xi_j = 1-(1-\mu)^j.
\end{equation}
This is the probability that a hard or soft mask vanishes within $j$
correct nucleotides.
\end{definition}

\begin{definition}
Given the divergence rate $\mu$, the probability that a duplicate sequence
contains a mismatch in a sequence of $j$ error-free nucleotides followed
by an error is
\begin{equation}
\tag{\ref{eq:eta}}
\eta_j = 1-(1-\mu)^j\mu/3.
\end{equation}
This is the probability that a hard or soft mask vanishes within $j$
correct nucleotides followed by a sequencing error.
\end{definition}

\section{Appendix}
\label{app_extra}

\subsection{Derivation of expression~(\ref{eq:F})}
\label{app_ex1}

In section~\ref{sec:example_exact}, we had to compute the top right entry
of the matrix $M_*(z)$ defined as $M_*(z) = M_0(z) + M_0(z)^2 + \ldots =
M_0(z) \cdot (I-M_0(z))^{-1}$, where
\begin{equation*}
M_0(z) =
\begin{bmatrix}
\big( 1+qz+\ldots+(qz)^{\gamma-1}
\big) pz  & 1+qz+\ldots+(qz)^{\gamma-1} \\
0 & 0 \\
\end{bmatrix}.
\end{equation*}

Since $I-M_0(z)$ is a $2\times2$ matrix, we can invert it analytically.
Observing that the determinant of $I-M_0(z)$ is $\Delta(z) = 1-\big(
1+qz+\ldots+(qz)^{\gamma-1}\big) pz$, we find
\begin{equation*}
(I-M_0(z))^{-1} = \frac{1}{\Delta(z)}
\begin{bmatrix}
1 & 1+qz+\ldots+(qz)^{\gamma-1} \\
0 & 1-\big( 1+qz+\ldots+(qz)^{\gamma-1} \big) pz
\end{bmatrix}.
\end{equation*}

Premultiplying by $M_0(z)$, we finally obtain
\begin{equation*}
M_*(z) = \frac{1}{\Delta(z)}
\begin{bmatrix}
\big( 1+qz+\ldots+(qz)^{\gamma-1} \big) pz &
1+qz+\ldots+(qz)^{\gamma-1} \\
0 & 0 \end{bmatrix},
\end{equation*}
where the top right term is equal to
\begin{equation}
\tag{\ref{eq:F}}
\frac{1+qz+\ldots+(qz)^{\gamma-1}}
{1-\big( 1+qz+\ldots+(qz)^{\gamma-1} \big) pz}.
\end{equation}


\subsection{Derivation of expression~(\ref{eq:recur})}
\label{app_rec}

In section~\ref{sec:example_exact}, we had to extract the Taylor
coefficients $a_0, a_1, a_2 \ldots$ of the function
\begin{equation*}
\frac{1+qz+\ldots+(qz)^{\gamma-1}}
  {1-\big(1+qz+\ldots+(qz)^{\gamma-1} \big) pz} =
  a_0 + a_1z +a_2z^2 + \ldots
\end{equation*}

Multipying both terms of the equation by $1-pz
\big(1+qz+\ldots+(qz)^{\gamma-1} \big)$ we obtain
\begin{equation*}
1+qz+\ldots+(qz)^{\gamma-1} =
\left(1-\big(1+qz+\ldots+(qz)^{\gamma-1} \big) pz\right)
(a_0 + a_1z +a_2z^2 + \ldots).
\end{equation*}

Multiplying again both terms of the equation by $1-qz$, we find
\begin{eqnarray*}
1-(qz)^\gamma &=& (1-qz) \left(1- \big(1+qz+\ldots+(qz)^{\gamma-1}
\big) pz\right) (a_0 + a_1z +a_2z^2 + \ldots) \\
&=& (1-z+pq^\gamma \cdot z^{\gamma+1}) (a_0 + a_1z +a_2z^2 + \ldots) \\
&=& a_0 + \sum_{k=1}^{\gamma} (a_k-a_{k-1})z^k +
  \sum_{k=\gamma+1}^{\infty} (a_k-a_{k-1}+ pq^\gamma \cdot
a_{k-\gamma-1})z^k.
\end{eqnarray*}

Balancing the terms of degree 0 on both sides of the equation forces $a_0
= 1$. The terms of degree 1 to degree $\gamma-1$ are null on the left
side, which implies $a_k - a_{k-1} = 0$ and consequently $a_k = a_0 = 1$
for $k = 1, 2, \ldots, \gamma-1$. The term of degree $\gamma$ is
$-q^\gamma$ on the left side, so $a_\gamma-a_{\gamma-1} = -q^\gamma$, or
$a_\gamma = 1-q^\gamma$. Finally, all the other terms on the left side
are null, which implies $a_k-a_{k-1}+ pq^\gamma \cdot a_{k-\gamma-1} = 0$,
or $a_k = a_{k-1}-pq^\gamma\cdot a_{k-\gamma-1}$ for $k = \gamma+1,
\gamma+2 \ldots$

In conclusion, the Taylor coefficients $a_0, a_1, a_2, \ldots$ satisfy the
recurrence equation
\begin{equation}
\tag{\ref{eq:recur}}
a_k = 
\begin{cases}
1            &\quad\text{if } k < \gamma, \\
1 -q^\gamma &\quad\text{if } k = \gamma, \\
a_{k-1} -pq^\gamma \cdot a_{k-\gamma-1} &\quad\text{otherwise.}
\end{cases}
\end{equation}

\subsection{An alternative construction of $M_n(z)$}
\label{app_Mn}

The alphabets described here are constructed so that there is exactly one
way to decompose reads in symbols or in segments. For a given alphabet
there exists only one transfer matrix that describes the reads that have
no seed of minimum size $\gamma$. However, if we choose a different
alphabet, we can obtain a different transfer matrix describing exactly the
same reads.

In section~\ref{sec:example_skip}, we decomposed the reads in
the so-called skip-$n$ alphabet $\mathcal{A}_n = \{\square, |,
\Downarrow_0, \Downarrow_1, \ldots, \Downarrow_n \}$, from which we
derived the transfer matrix $M_n(z)$ shown in expression
(\ref{eq_matrix_Mn}). We now introduce the alternative skip-$n$ alphabet
$\mathcal{A}^*_n = \{\square, *, |, \Downarrow_0, \Downarrow_1, \ldots,
\Downarrow_n \}$, where we add the symbol $*$.

The $*$ symbol stands for the nucleotides between a $\Downarrow_j$
terminator ($0 \leq j \leq n)$ and the following non-skipped position.
Recall that seed can only start at non-skipped positions occurring every
$n+1$ nucleotides, and that the $\Downarrow_j$ indicates a sequencing
error $j$ nucleotides before a non-skipped position.
Figure~\ref{fig_alt_skip} shows the read of Figure~\ref{fig:skip} in the
alternative skip-3 alphabet. The $*$ symbols appear after the
$\Downarrow_1$ and $\Downarrow_3$ terminators. They are not found after a
$\Downarrow_0$ terminator because there are no nucleotides between this
terminator and the following non-skipped position.

\begin{figure}[h]
\centering
\includegraphics[scale=0.85]{alternative_sketch_skip.pdf}
\caption{\textbf{The alternative skip encoding.}
The read of Figure~\ref{fig:skip} is represented in the alternative skip-3
alphabet. The only difference is that the nucleotides between a
$\Downarrow_j$ terminator ($0 \leq j \leq n$) and the following
non-skipped position are replaced by the $*$ symbol.}
\label{fig_alt_skip}
\end{figure}

The match status of the $*$ nucleotides is irrelevant. Indeed, after a
$\Downarrow_j$ symbol one has to ``wait''until the next potential seed can
start, $j$ nucleotides further down. The weighted generating function of a
$*$ nucleotide is thus $z$, as it stands for any nucleotide.

A sequence of $*$ symbols can end in only two ways: either with the end of
the read (as in the case of Figure~\ref{fig_alt_skip}), or with a
non-skipped position. If the end of the read comes first, the sequence of
$*$ symbols is terminated by the usual $|$ terminator. Otherwise, the
sequence has no terminator but it puts the read in exactly the same state
as after a $\Downarrow_0$ terminator.

This means that in the alternative transfer matrix, the entries associated
to $\Downarrow_j$ ($1 \leq j \leq n)$ simply ``fast forward'' to the
entries associated with $\Downarrow_0$ and $|$. It takes exactly $j$
nucleotides of any kind to go from a $\Downarrow_j$ symbol to the next
non-skipped position, with weighted generating function $z^j$. If the end
of the read occurs before the next non-skipped position, the
$\Downarrow_j$ will be followed by a tail segment of up to $j-1$ symbols
$*$, with weighted generating expression $1 + z + \ldots + z^{j-1}$. The
segments following the $\Downarrow_0$ terminator are unchanged compared to
the original expression of the transfer matrix.

Finally, the expression of  the transfer matrix $M_n^*(z)$ in the
alternative skip-$n$ alphabet is
\begin{equation}
\label{eq_alt_Mn}
\begin{blockarray}{cccccc}
   & \Dn{0} & \Dn{1} & \ldots & \Dn{n} & \nd \\
\begin{block}{c[ccccc]}
\Dn{0} & H_{0,0}(z) & H_{0,1}(z) & \ldots & H_{0,n}(z) & J_0(z) \\
\Dn{1} & z & 0 & \ldots & 0 & N_0(z) \\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\Dn{n} & z^n & 0 & \ldots & 0 & N_{n-1}(z) \\
\nd & 0 & 0 & \ldots & 0 & 0 \\
\end{block}
\end{blockarray},
\end{equation}
where $p$ is the error rate of the sequencer, $q=1-p$, where $n$ is the
number of skipped nucleotides between potential seeds, where $\gamma$ is
the minimum seed length, and where
\begin{gather}
\tag{\ref{eq_H}}
H_{0,j}(z) = (qz)^x\big( 1 + (qz)^{n+1} +
  \ldots + (qz)^{m(n+1)} \big) pz, \\
\notag
  \text{with } x = -j-1 \modulo{n+1},
  \text{ and } m = \left\lfloor
  \frac{\gamma-1-x}{n+1} \right\rfloor, \\
\tag{\ref{eq_J}}
J_0(z) = 1 + qz + (qz)^2 + \ldots + (qz)^{\gamma-1}, \\
\tag{\ref{eq_N}}
N_i(z) = 1+z+\ldots+z^i.
\end{gather}

Observe that this expression is simpler than (\ref{eq_matrix_Mn}). It
could have been used in section \ref{sec:example_skip} because it is also
easier to derive, but the burden of computations with expression
(\ref{eq_alt_Mn}) is heavier. The reason is that the top right entry of
$M^*_n(z)^{s+1}$ is not the weighted generating function of reads with $s$
sequencing errors ($s \geq 1$), so we cannot use the probability that the
reads contains more than $s$ errors as a bound on the neglected terms. As
a consequence, we would need to perform more iterations in order to
ascertain that the estimates are accurate to within chosen $\varepsilon$.

\subsection{Proof that $a_k$ is independent of $M_n(z)^m$ for $m > k+1$}
\label{app_skip}

In section~\ref{sec:example_skip} we considered the transfer matrix
$M_n(z)$ of reads containing no skip-$n$ seed. The quantity of interest
$a_k$ is the coefficent of $z^k$ in the Taylor expansion of the top right
term of $M_n(z) + M_n(z)^2 + M_n(z)^3 + \ldots$ We claimed that the
coefficients $a_0, a_1, \ldots, a_k$ are independent of $M_n(z)^{k+2},
M_n(z)^{k+3}, \ldots$ so that they can be computed from the finite sum
$M_n(z) + M_n(z)^2 + \ldots + M_n(z)^{k+1}$.

We proceed by induction and show that for $k \geq 1$ all the entries of
$M_n(z)^k$ are multiples of $z^{k-1}$. For $k = 1$ the statement is
trivial and there is nothing to show. Now assume that for some $k > 1$,
all the entries of $M_n(z)^k$ are multiples of $z^{k-1}$. Observe that
from the definition of $M_n(z)$ in expression (\ref{eq_matrix_Mn}), the
last row of $M_n(z)^m$ consists of zeros only for all $m \geq 1$. So in
the matrix product $M_n(z) \cdot M_n(z)^k$, the polynomials $J_0(z),
\ldots, J_n(z)$ in the last column of $M_n(z)$ are all multiplied by 0.
The remaining terms of $M_n(z)$ are multiples of $z$, so applying the
induction hypothesis shows that all the terms of $M_n(z)^{k+1}$ are
multiples of $z^k$.

Since all the terms of $M(z)^m$ are multiples of $z^{k+1}$ for $m \geq
k+1$, the coefficient of $z^k$ is 0 in the top right term of every matrix
$M(z)^m$ for $m \geq k+1$. As a result, the coefficient of $z^k$ in the
top right entry of $M_n(z) + M_n(z)^2 + M_n(z)^3 + \ldots$ is the same as
in $M_n(z) + M_n(z)^2 + \ldots + M_n(z)^{k+1}$, as we had to demonstrate.
The same rationale holds for the coefficients of $z^m$ $(0 \leq m < k)$,
so finally the coefficients $a_0, a_1, \ldots, a_k$ can all be computed
from the top right entry of $M_n(z) + M_n(z)^2 + \ldots + M_n(z)^{k+1}$ as
claimed.

\end{document}

%gs -dNoOutputFonts -sDEVICE=pdfwrite -o out.pdf latex.pdf 
